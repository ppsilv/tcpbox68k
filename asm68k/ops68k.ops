#########################################################
#							#
#	Motorola 68000 Mnemonics and Op Codes		#
#							#
#	This file is to be processed with 'op68k'	#
#	to generate the header file that is included	#
#	into the asm68k assembler source code.		#
#							#
#########################################################

#
#	Each Mnemonic/Opcode description line has the
#	following format:
#
#		{mnemonic},{sizing},{arg1},{arg2},{opcode},{sizebit},{offset1},{offset2},{flags}
#
#	Where:
#
#		mnemonic	The text name of the assembly statement
#
#		sizing		Size suffixes allowed
#
#		arg1,arg2	The type of the argument
#
#		opcode		The base 16 bit value for the instruction
#
#		sizebit		Bit position of size data if used
#
#		offset1,offset2	The bit position offset for each argument
#
#		flags		Notes to assembler that specific care needs to be applied on this opcode
#
#	Arg values are:
#
#	NO_ARGUMENT		Argument should be empty
#
#	EA_DREG			EA 000: Dn, Data Register Direct
#	EA_AREG			EA 001: An, Address Register Direct
#	EA_AREG_IND		EA 010: (An), Address Register Indirect
#	EA_AREG_IND_INC		EA 011: (An)+, Address Register Indirect with post-increment
#	EA_AREG_DEC_IND		EA 100: -(An), Address Register Indirect with pre-decrement
#	EA_AREG_IND_DISP	EA 101: d16(An), Address Register Indirect with 16 bit displacement
#	EA_AREG_IND_DISP_REG	EA 110: d8(An,Rm.s), Address Register Indirect with 8 bit displacement and Register offset
#	EA_ABS_SHORT_IND	EA 111 000: a16, absolute indirect 16 bit address
#	EA_ABS_LONG_IND		EA 111 001: a32, absolute indirect 32 bit address
#	EA_PC_IND_DISP		EA 111 010: d16(PC), PC Indirect with 16 bit displacement
#	EA_PC_IND_DISP_REG	EA 111 011: d8(PC,Rm.s), PC Indirect with 8 bit displacement and Register offset
#	EA_IMMEDIATE		EA 111 100: #i, an immediate value in byte, word or long form (used as source only)
#	EA_STATUS_REG		EA 111 100: SR, The status register (used as destination only)
#	EA_FLAGS_REG		EA 111 100: CCR, The condition codes register (used as destination only)
#
#	REGISTER_LIST		A specific argument type for the MOVEM opcode.
#	REL_BRANCH_8		An 8 bit signed value used a PC offset.
#	REL_BRANCH_16		A 16 bit signed value used a PC offset.
#	NUM_DREG		Number: Dn, Data Register Direct.
#	NUM_AREG		Number: An, Address Register Direct.
#	NUM_AREG_DEC_IND	Number: -(An), Address Register Indirect with pre-decrement.
#	NUM_AREG_IND_INC	Number: (An)+, Address Register Indirect with post-increment.
#	NUM_IMMEDIATE_3BIT	Number: #i, An unsigned bit number from 0 to 7.
#	NUM_IMEMDIATE_3QUICK	Number: #i, and unsigned number from 1 to 8.
#	NUM_IMMEDIATE_5BIT	Number: #i, An unsigned bit number from 0 to 31.
#	NUM_IMMEDIATE_8		Number: #i, a number (signed or unsigned?) in the 8 bit range.
#	NUM_IMMEDIATE_16	Number: #i, a number (signed or unsigned?) in the 16 bit range.
#	CONTROL_REG		One of a set of CPU control registers
#
#	EA_SOURCE_ARG		Generic set of EAs that are common source arguments (all EAs except SR and CCR).
#	EA_DEST_ARG		Generic set of EAs that are common destination arguments (all EAs except An, PC relatives, SR and CCR).
#	EA_MEMORY_ARG		Set of EAs that are memory destination arguments (except PC relatives).
#
#	EA_TO_MEM_ARG		MOVEM to memory EAs
#	EA_FROM_MEM_ARG		MOVEM from memory EAs
#
#	SIZE_WL			1 bit, 0:Word, 1:Long
#	SIZE_BWL		2 bits, 00:Byte, 01:Word, 10:Long
#
#	Flags
#	-----
#
#	NO_FLAGS		Nothing extra required.
#	FLAG_REV_ARG_1		Reverse bit order of argument 1
#	FLAG_COMP_SIZE		The size bits must be complemented
#	FLAG_USP_ONLY		Only the USP control register allowed
#	FLAG_4			Spare
#	FLAG_5			Spare
#	FLAG_68000		68010 Instructions
#	FLAG_68010		68010 Instructions
#	FLAG_68020		68020 Instructions
#	FLAG_68030		68030 Instructions
#	FLAG_68881		FPU Instructions
#
#
#	The descriptions of the instructions detailed below were derived
#	from the 1985 Sybex book "Programming the 68000" by Steve Williams.

#
#	Motorola 68000 Opcodes
#	======================
#

#
#	Binary Coded Decimal (BCD) Addition
#
ABCD,	SIZE_B,		NUM_DREG,		NUM_DREG,		0xC100,	0x0000,	0,	0,	9,	FLAG_68000
ABCD,	SIZE_B,		NUM_AREG_DEC_IND,	NUM_AREG_DEC_IND,	0xC108,	0x0000,	0,	0,	9,	FLAG_68000
#
#	Addition of simple numbers
#
ADD,	SIZE_BWL,	NUM_DREG,		EA_MEMORY_ARG,		0xD100,	0x0000,	6,	9,	0,	FLAG_68000
ADD,	SIZE_BWL,	EA_SOURCE_ARG,		NUM_DREG,		0xD000,	0x0000,	6,	0,	9,	FLAG_68000
ADDA,	SIZE_WL,	EA_SOURCE_ARG,		NUM_AREG,		0xD0C0,	0x0000,	8,	0,	9,	FLAG_68000
ADDI,	SIZE_BWL,	EA_IMMEDIATE,		EA_DEST_ARG,		0x0600,	0x0000,	6,	APPEND,	0,	FLAG_68000
ADDQ,	SIZE_BWL,	NUM_IMMEDIATE_QUICK,	EA_DEST_ARG|EA_AREG,	0x5000,	0x0000,	6,	9,	0,	FLAG_68000
ADDX,	SIZE_BWL,	NUM_DREG,		NUM_DREG,		0xD100,	0x0000,	6,	9,	0,	FLAG_68000
ADDX,	SIZE_BWL,	NUM_AREG_DEC_IND,	NUM_AREG_DEC_IND,	0xD108,	0x0000,	6,	9,	0,	FLAG_68000
#
#	Logical AND
#
AND,	SIZE_BWL,	NUM_DREG,		EA_MEMORY_ARG,		0xC100,	0x0000,	6,	9,	0,	FLAG_68000
AND,	SIZE_BWL,	EA_SOURCE_ARG,		NUM_DREG,		0xC000,	0x0000,	6,	0,	9,	FLAG_68000
ANDI,	SIZE_BWL,	EA_IMMEDIATE,		EA_DEST_ARG,		0x0200,	0x0000,	6,	APPEND,	0,	FLAG_68000
#
#	Arithmetic shifting left or right.
#
ASL,	SIZE_BWL,	NUM_IMMEDIATE_QUICK,	NUM_DREG,		0xE100,	0x0000,	6,	9,	0,	FLAG_68000
ASL,	SIZE_BWL,	NUM_DREG,		NUM_DREG,		0xE120,	0x0000,	6,	9,	0,	FLAG_68000
ASL,	SIZE_W,		EA_MEMORY_ARG,		NO_ARGUMENT,		0xE1C0,	0x0000,	0,	0,	0,	FLAG_68000
ASR,	SIZE_BWL,	NUM_IMMEDIATE_QUICK,	NUM_DREG,		0xE000,	0x0000,	6,	9,	0,	FLAG_68000
ASR,	SIZE_BWL,	NUM_DREG,		NUM_DREG,		0xE020,	0x0000,	6,	9,	0,	FLAG_68000
ASR,	SIZE_W,		EA_MEMORY_ARG,		NO_ARGUMENT,		0xE0C0,	0x0000,	0,	0,	0,	FLAG_68000
#
#	Branching (and Calling) via Relative PC address
#
#	Note:
#		BSR (Branch to subroutine) is hidden in its 'proper' place below.
#		BCC has the alias BHS
#		BCS has the alias BLO
#
BRA,	NO_SIZE,	ABS_ADDRESS,		NO_ARGUMENT,		0x6000,	0x0000,	0,	0,	0,	FLAG_68000|FLAG_8_16_REL
BSR,	NO_SIZE,	ABS_ADDRESS,		NO_ARGUMENT,		0x6100,	0x0000,	0,	0,	0,	FLAG_68000|FLAG_8_16_REL
BHI,	NO_SIZE,	ABS_ADDRESS,		NO_ARGUMENT,		0x6200,	0x0000,	0,	0,	0,	FLAG_68000|FLAG_8_16_REL
BLS,	NO_SIZE,	ABS_ADDRESS,		NO_ARGUMENT,		0x6300,	0x0000,	0,	0,	0,	FLAG_68000|FLAG_8_16_REL
BCC,	NO_SIZE,	ABS_ADDRESS,		NO_ARGUMENT,		0x6400,	0x0000,	0,	0,	0,	FLAG_68000|FLAG_8_16_REL
BHS,	NO_SIZE,	ABS_ADDRESS,		NO_ARGUMENT,		0x6400,	0x0000,	0,	0,	0,	FLAG_68000|FLAG_8_16_REL
BCS,	NO_SIZE,	ABS_ADDRESS,		NO_ARGUMENT,		0x6500,	0x0000,	0,	0,	0,	FLAG_68000|FLAG_8_16_REL
BLO,	NO_SIZE,	ABS_ADDRESS,		NO_ARGUMENT,		0x6500,	0x0000,	0,	0,	0,	FLAG_68000|FLAG_8_16_REL
BNE,	NO_SIZE,	ABS_ADDRESS,		NO_ARGUMENT,		0x6600,	0x0000,	0,	0,	0,	FLAG_68000|FLAG_8_16_REL
BEQ,	NO_SIZE,	ABS_ADDRESS,		NO_ARGUMENT,		0x6700,	0x0000,	0,	0,	0,	FLAG_68000|FLAG_8_16_REL
BVC,	NO_SIZE,	ABS_ADDRESS,		NO_ARGUMENT,		0x6800,	0x0000,	0,	0,	0,	FLAG_68000|FLAG_8_16_REL
BVS,	NO_SIZE,	ABS_ADDRESS,		NO_ARGUMENT,		0x6900,	0x0000,	0,	0,	0,	FLAG_68000|FLAG_8_16_REL
BPL,	NO_SIZE,	ABS_ADDRESS,		NO_ARGUMENT,		0x6A00,	0x0000,	0,	0,	0,	FLAG_68000|FLAG_8_16_REL
BMI,	NO_SIZE,	ABS_ADDRESS,		NO_ARGUMENT,		0x6B00,	0x0000,	0,	0,	0,	FLAG_68000|FLAG_8_16_REL
BGE,	NO_SIZE,	ABS_ADDRESS,		NO_ARGUMENT,		0x6C00,	0x0000,	0,	0,	0,	FLAG_68000|FLAG_8_16_REL
BLT,	NO_SIZE,	ABS_ADDRESS,		NO_ARGUMENT,		0x6D00,	0x0000,	0,	0,	0,	FLAG_68000|FLAG_8_16_REL
BGT,	NO_SIZE,	ABS_ADDRESS,		NO_ARGUMENT,		0x6E00,	0x0000,	0,	0,	0,	FLAG_68000|FLAG_8_16_REL
BLE,	NO_SIZE,	ABS_ADDRESS,		NO_ARGUMENT,		0x6F00,	0x0000,	0,	0,	0,	FLAG_68000|FLAG_8_16_REL
#
#	Bit twiddling
#
BCHG,	SIZE_B,		NUM_DREG,		EA_MEMORY_ARG,		0x0140,	0x0000,	0,	9,	0,	FLAG_68000
BCHG,	SIZE_L,		NUM_DREG,		EA_DREG,		0x0140,	0x0000,	0,	9,	0,	FLAG_68000
BCHG,	SIZE_B,		NUM_IMMEDIATE_3BIT,	EA_MEMORY_ARG,		0x0840,	0x0000,	0,	APPEND,	0,	FLAG_68000
BCHG,	SIZE_L,		NUM_IMMEDIATE_5BIT,	EA_DREG,		0x0840,	0x0000,	0,	APPEND,	0,	FLAG_68000
#
BCLR,	SIZE_B,		NUM_DREG,		EA_MEMORY_ARG,		0x0180,	0x0000,	0,	9,	0,	FLAG_68000
BCLR,	SIZE_L,		NUM_DREG,		EA_DREG,		0x0180,	0x0000,	0,	9,	0,	FLAG_68000
BCLR,	SIZE_B,		NUM_IMMEDIATE_3BIT,	EA_MEMORY_ARG,		0x0880,	0x0000,	0,	APPEND,	0,	FLAG_68000
BCLR,	SIZE_L,		NUM_IMMEDIATE_5BIT,	EA_DREG,		0x0880,	0x0000,	0,	APPEND,	0,	FLAG_68000
#
BSET,	SIZE_B,		NUM_DREG,		EA_MEMORY_ARG,		0x01C0,	0x0000,	0,	9,	0,	FLAG_68000
BSET,	SIZE_L,		NUM_DREG,		EA_DREG,		0x01C0,	0x0000,	0,	9,	0,	FLAG_68000
BSET,	SIZE_B,		NUM_IMMEDIATE_3BIT,	EA_MEMORY_ARG,		0x08C0,	0x0000,	0,	APPEND,	0,	FLAG_68000
BSET,	SIZE_L,		NUM_IMMEDIATE_5BIT,	EA_DREG,		0x08C0,	0x0000,	0,	APPEND,	0,	FLAG_68000
#
BTST,	SIZE_B,		NUM_DREG,		EA_MEMORY_ARG,		0x0100,	0x0000,	0,	9,	0,	FLAG_68000
BTST,	SIZE_L,		NUM_DREG,		EA_DREG,		0x0100,	0x0000,	0,	9,	0,	FLAG_68000
BTST,	SIZE_B,		NUM_IMMEDIATE_3BIT,	EA_MEMORY_ARG,		0x0800,	0x0000,	0,	APPEND,	0,	FLAG_68000
BTST,	SIZE_L,		NUM_IMMEDIATE_5BIT,	EA_DREG,		0x0800,	0x0000,	0,	APPEND,	0,	FLAG_68000
#
CHK,	SIZE_W,		EA_SOURCE_ARG,		NUM_DREG,		0x4180,	0x0000,	0,	0,	9,	FLAG_68000
#
CLR,	SIZE_BWL,	EA_DEST_ARG,		NO_ARGUMENT,		0x4200,	0x0000,	6,	0,	0,	FLAG_68000
#
CMP,	SIZE_BWL,	EA_SOURCE_ARG,		NUM_DREG,		0xB000,	0x0000,	6,	0,	9,	FLAG_68000
CMPA,	SIZE_WL,	EA_SOURCE_ARG,		NUM_AREG,		0xB0C0,	0x0000,	8,	0,	9,	FLAG_68000
CMPI,	SIZE_BWL,	EA_IMMEDIATE,		EA_DEST_ARG,		0x0C00,	0x0000,	6,	APPEND,	0,	FLAG_68000
CMPM,	SIZE_BWL,	NUM_AREG_IND_INC,	NUM_AREG_IND_INC,	0xB108,	0x0000,	6,	0,	9,	FLAG_68000
#
#	Decrement and branch PC relative
#
#	Note:
#		DBF has the alias DBRA
#		DBCC has the alias DBHS
#		DBCS has the alias DBLO
#
DBT,	SIZE_W,		NUM_DREG,		ABS_ADDRESS,		0x50C8,	0x0000,	0,	0,	APPEND,	FLAG_68000|FLAG_16_REL
DBF,	SIZE_W,		NUM_DREG,		ABS_ADDRESS,		0x51C8,	0x0000,	0,	0,	APPEND,	FLAG_68000|FLAG_16_REL
DBRA,	SIZE_W,		NUM_DREG,		ABS_ADDRESS,		0x51C8,	0x0000,	0,	0,	APPEND,	FLAG_68000|FLAG_16_REL
DBHI,	SIZE_W,		NUM_DREG,		ABS_ADDRESS,		0x52C8,	0x0000,	0,	0,	APPEND,	FLAG_68000|FLAG_16_REL
DBLS,	SIZE_W,		NUM_DREG,		ABS_ADDRESS,		0x53C8,	0x0000,	0,	0,	APPEND,	FLAG_68000|FLAG_16_REL
DBCC,	SIZE_W,		NUM_DREG,		ABS_ADDRESS,		0x54C8,	0x0000,	0,	0,	APPEND,	FLAG_68000|FLAG_16_REL
DBHS,	SIZE_W,		NUM_DREG,		ABS_ADDRESS,		0x54C8,	0x0000,	0,	0,	APPEND,	FLAG_68000|FLAG_16_REL
DBCS,	SIZE_W,		NUM_DREG,		ABS_ADDRESS,		0x55C8,	0x0000,	0,	0,	APPEND,	FLAG_68000|FLAG_16_REL
DBLO,	SIZE_W,		NUM_DREG,		ABS_ADDRESS,		0x55C8,	0x0000,	0,	0,	APPEND,	FLAG_68000|FLAG_16_REL
DBNE,	SIZE_W,		NUM_DREG,		ABS_ADDRESS,		0x56C8,	0x0000,	0,	0,	APPEND,	FLAG_68000|FLAG_16_REL
DBEQ,	SIZE_W,		NUM_DREG,		ABS_ADDRESS,		0x57C8,	0x0000,	0,	0,	APPEND,	FLAG_68000|FLAG_16_REL
DBVC,	SIZE_W,		NUM_DREG,		ABS_ADDRESS,		0x58C8,	0x0000,	0,	0,	APPEND,	FLAG_68000|FLAG_16_REL
DBVS,	SIZE_W,		NUM_DREG,		ABS_ADDRESS,		0x59C8,	0x0000,	0,	0,	APPEND,	FLAG_68000|FLAG_16_REL
DBPL,	SIZE_W,		NUM_DREG,		ABS_ADDRESS,		0x5AC8,	0x0000,	0,	0,	APPEND,	FLAG_68000|FLAG_16_REL
DBMI,	SIZE_W,		NUM_DREG,		ABS_ADDRESS,		0x5BC8,	0x0000,	0,	0,	APPEND,	FLAG_68000|FLAG_16_REL
DBGE,	SIZE_W,		NUM_DREG,		ABS_ADDRESS,		0x5CC8,	0x0000,	0,	0,	APPEND,	FLAG_68000|FLAG_16_REL
DBLT,	SIZE_W,		NUM_DREG,		ABS_ADDRESS,		0x5DC8,	0x0000,	0,	0,	APPEND,	FLAG_68000|FLAG_16_REL
DBGT,	SIZE_W,		NUM_DREG,		ABS_ADDRESS,		0x5EC8,	0x0000,	0,	0,	APPEND,	FLAG_68000|FLAG_16_REL
DBLE,	SIZE_W,		NUM_DREG,		ABS_ADDRESS,		0x5FC8,	0x0000,	0,	0,	APPEND,	FLAG_68000|FLAG_16_REL
#
#	Divide Instructions
#
DIVS,	SIZE_W,		EA_SOURCE_ARG,		NUM_DREG,		0x81C0,	0x0000,	0,	0,	9,	FLAG_68000
DIVU,	SIZE_W,		EA_SOURCE_ARG,		NUM_DREG,		0x80C0,	0x0000,	0,	0,	9,	FLAG_68000
#
#	Exclusive OR, EOR or XOR
#
EOR,	SIZE_BWL,	NUM_DREG,		EA_DEST_ARG,		0xB100,	0x0000,	6,	9,	0,	FLAG_68000
XOR,	SIZE_BWL,	NUM_DREG,		EA_DEST_ARG,		0xB100,	0x0000,	6,	9,	0,	FLAG_68000
EORI,	SIZE_BWL,	EA_IMMEDIATE,		EA_DEST_ARG,		0x0A00,	0x0000,	6,	APPEND,	0,	FLAG_68000
XORI,	SIZE_BWL,	EA_IMMEDIATE,		EA_DEST_ARG,		0x0A00,	0x0000,	6,	APPEND,	0,	FLAG_68000
#
#	Exchange whole registers
#
EXG,	SIZE_L,		NUM_DREG,		NUM_DREG,		0xC140,	0x0000,	0,	9,	0,	FLAG_68000
EXG,	SIZE_L,		NUM_AREG,		NUM_AREG,		0xC148,	0x0000,	0,	9,	0,	FLAG_68000
EXG,	SIZE_L,		NUM_DREG,		NUM_AREG,		0xC188,	0x0000,	0,	9,	0,	FLAG_68000
#
#	Sign extension instructions.
#
EXT,	SIZE_WL,	NUM_DREG,		NO_ARGUMENT,		0x4800,	0x0000,	6,	0,	0,	FLAG_68000
#
#	The Illegal instruction
#
ILLEGAL,NO_SIZE,	NO_ARGUMENT,		NO_ARGUMENT,		0x4AFC,	0x0000,	0,	0,	0,	FLAG_68000
#
#	Jump to, or call, another location in the program
#
JMP,	NO_SIZE,	EA_ADDRESS_ARG,		NO_ARGUMENT,		0x4EC0,	0x0000,	0,	0,	0,	FLAG_68000
JSR,	NO_SIZE,	EA_ADDRESS_ARG,		NO_ARGUMENT,		0x4E80,	0x0000,	0,	0,	0,	FLAG_68000
#
#	Load an Effective Address into a register
#
LEA,	NO_SIZE,	EA_ADDRESS_ARG,		NUM_AREG,		0x41C0,	0x0000,	0,	0,	9,	FLAG_68000
#
#	Create Stack Frame
#
LINK,	NO_SIZE,	NUM_AREG,		NUM_IMMEDIATE_16,	0x4E50,	0x0000,	0,	0,	APPEND,	FLAG_68000
#
#	Logical shifting left or right
#
LSL,	SIZE_BWL,	NUM_DREG,		NUM_DREG,		0xE128,	0x0000,	6,	9,	0,	FLAG_68000
LSL,	SIZE_BWL,	NUM_IMMEDIATE_QUICK,	NUM_DREG,		0xE108,	0x0000,	6,	9,	0,	FLAG_68000
LSL,	SIZE_W,		EA_MEMORY_ARG,		NO_ARGUMENT,		0xE3C0,	0x0000,	0,	0,	0,	FLAG_68000
LSR,	SIZE_BWL,	NUM_DREG,		NUM_DREG,		0xE028,	0x0000,	6,	9,	0,	FLAG_68000
LSR,	SIZE_BWL,	NUM_IMMEDIATE_QUICK,	NUM_DREG,		0xE008,	0x0000,	6,	9,	0,	FLAG_68000
LSR,	SIZE_W,		EA_MEMORY_ARG,		NO_ARGUMENT,		0xE2C0,	0x0000,	0,	0,	0,	FLAG_68000
#
#	Move data between places.
#
MOVE,	SIZE_BWL,	EA_SOURCE_ARG,		EA_DEST_ARG,		0x0000,	0x0000,	12,	0,	9,	FLAG_68000
MOVE,	SIZE_W,		EA_SOURCE_ARG,		EA_FLAGS_REG,		0x44C0,	0x0000,	0,	0,	IGNORE,	FLAG_68000
MOVE,	SIZE_W,		EA_SOURCE_ARG,		EA_STATUS_REG,		0x46C0,	0x0000,	0,	0,	IGNORE,	FLAG_68000
MOVE,	SIZE_W,		EA_STATUS_REG,		EA_DEST_ARG,		0x40C0,	0x0000,	0,	IGNORE,	0,	FLAG_68000
MOVE,	SIZE_L,		CONTROL_REG,		NUM_AREG,		0x4E64,	0x0000,	0,	IGNORE,	0,	FLAG_68000|FLAG_USP_ONLY
MOVE,	SIZE_L,		NUM_AREG,		CONTROL_REG,		0x4E60,	0x0000,	0,	0,	IGNORE,	FLAG_68000|FLAG_USP_ONLY
MOVEA,	SIZE_WL,	EA_SOURCE_ARG,		NUM_AREG,		0x2040,	0x0000,	12,	0,	9,	FLAG_68000|FLAG_COMP_SIZE
#
#	Note:
#		The register to bit number mapping is not consistent.  For all EAs
#		the default mapping is 15:A7..8:A0,7:D7..0:D0.  For the pre-decrement
#		EA (when storing register into the stack) this order is reversed.
#
MOVEM,	SIZE_WL,	REGISTER_LIST,	EA_MOVEM_ARG,			0x4880,	0x0000,	6,	APPEND,	0,	FLAG_68000
MOVEM,	SIZE_WL,	REGISTER_LIST,	EA_AREG_DEC_IND,		0x4880,	0x0000,	6,	APPEND,	0,	FLAG_68000|FLAG_REV_ARG_1
MOVEM,	SIZE_WL,	EA_MOVEM_ARG|EA_AREG_IND_INC,	REGISTER_LIST,	0x4C80,	0x0000,	6,	0,	APPEND,	FLAG_68000
#
#	The Peripheral IO move instruction.
#
MOVEP,	SIZE_WL,	NUM_DREG,		EA_AREG_IND_DISP,	0x0188,	0x0000,	6,	9,	0,	FLAG_68000
MOVEP,	SIZE_WL,	EA_AREG_IND_DISP,	NUM_DREG,		0x0108,	0x0000,	6,	0,	9,	FLAG_68000
#
#	Quick move immediate value into register
#
MOVEQ,	SIZE_L,		NUM_IMMEDIATE_8,	NUM_DREG,		0x7000,	0x0000,	0,	0,	9,	FLAG_68000
#
#	Multiplication
#
MULS,	SIZE_W,		EA_SOURCE_ARG,		NUM_DREG,		0xC1C0,	0x0000,	0,	0,	9,	FLAG_68000
MULU,	SIZE_W,		EA_SOURCE_ARG,		NUM_DREG,		0xC0C0,	0x0000,	0,	0,	9,	FLAG_68000
#
#	Negate BCD value
#
NBCD,	SIZE_B,		EA_DEST_ARG,		NO_ARGUMENT,		0x4800,	0x0000,	0,	0,	0,	FLAG_68000
#
#	Negate binary numbers
#
NEG,	SIZE_BWL,	EA_DEST_ARG,		NO_ARGUMENT,		0x4400,	0x0000,	6,	0,	0,	FLAG_68000
NEGX,	SIZE_BWL,	EA_DEST_ARG,		NO_ARGUMENT,		0x4000,	0x0000,	6,	0,	0,	FLAG_68000
#
#	No Operation
#
NOP,	NO_SIZE,	NO_ARGUMENT,		NO_ARGUMENT,		0x4E71,	0x0000,	0,	0,	0,	FLAG_68000
#
#	Not binary value.
#
NOT,	SIZE_BWL,	EA_DEST_ARG,		NO_ARGUMENT,		0x4600,	0x0000,	6,	0,	0,	FLAG_68000
#
#	Logical OR instruction.
#
OR,	SIZE_BWL,	NUM_DREG,		EA_MEMORY_ARG,		0x8100,	0x0000,	6,	9,	0,	FLAG_68000
OR,	SIZE_BWL,	EA_SOURCE_ARG,		NUM_DREG,		0x8000,	0x0000,	6,	0,	9,	FLAG_68000
ORI,	SIZE_BWL,	EA_IMMEDIATE,		EA_DEST_ARG,		0x0000,	0x0000,	6,	APPEND,	0,	FLAG_68000
#
#	Push an Effective Address onto the stack
#
PEA,	NO_SIZE,	EA_ADDRESS_ARG,		NO_ARGUMENT,		0x4840,	0x0000,	0,	0,	9,	FLAG_68000
#
#	Cause a system reset
#
RESET,	NO_SIZE,	NO_ARGUMENT,		NO_ARGUMENT,		0x4E70,	0x0000,	0,	0,	0,	FLAG_68000
#
#	Rotate left or right
#
ROL,	SIZE_BWL,	NUM_DREG,		NUM_DREG,		0xE138,	0x0000,	6,	9,	0,	FLAG_68000
ROL,	SIZE_BWL,	NUM_IMMEDIATE_QUICK,	NUM_DREG,		0xE118,	0x0000,	6,	9,	0,	FLAG_68000
ROL,	SIZE_W,		EA_MEMORY_ARG,		NO_ARGUMENT,		0xE7C0,	0x0000,	0,	0,	0,	FLAG_68000
ROR,	SIZE_BWL,	NUM_DREG,		NUM_DREG,		0xE038,	0x0000,	6,	9,	0,	FLAG_68000
ROR,	SIZE_BWL,	NUM_IMMEDIATE_QUICK,	NUM_DREG,		0xE018,	0x0000,	6,	9,	0,	FLAG_68000
ROR,	SIZE_W,		EA_MEMORY_ARG,		NO_ARGUMENT,		0xE6C0,	0x0000,	0,	0,	0,	FLAG_68000
#
#	Rotate left or right through the X bit
#
ROXL,	SIZE_BWL,	NUM_DREG,		NUM_DREG,		0xE130,	0x0000,	6,	9,	0,	FLAG_68000
ROXL,	SIZE_BWL,	NUM_IMMEDIATE_QUICK,	NUM_DREG,		0xE110,	0x0000,	6,	9,	0,	FLAG_68000
ROXL,	SIZE_W,		EA_MEMORY_ARG,		NO_ARGUMENT,		0xE5C0,	0x0000,	0,	0,	0,	FLAG_68000
ROXR,	SIZE_BWL,	NUM_DREG,		NUM_DREG,		0xE030,	0x0000,	6,	9,	0,	FLAG_68000
ROXR,	SIZE_BWL,	NUM_IMMEDIATE_QUICK,	NUM_DREG,		0xE010,	0x0000,	6,	9,	0,	FLAG_68000
ROXR,	SIZE_W,		EA_MEMORY_ARG,		NO_ARGUMENT,		0xE4C0,	0x0000,	0,	0,	0,	FLAG_68000
#
#	Return from an exception or subroutine
#
RTE,	NO_SIZE,	NO_ARGUMENT,		NO_ARGUMENT,		0x4E73,	0x0000,	0,	0,	0,	FLAG_68000
RTR,	NO_SIZE,	NO_ARGUMENT,		NO_ARGUMENT,		0x4E77,	0x0000,	0,	0,	0,	FLAG_68000
RTS,	NO_SIZE,	NO_ARGUMENT,		NO_ARGUMENT,		0x4E75,	0x0000,	0,	0,	0,	FLAG_68000
#
#	Binary Coded Decimal (BCD) Subtraction
#
SBCD,	SIZE_B,		NUM_DREG,		NUM_DREG,		0x8100,	0x0000,	0,	0,	9,	FLAG_68000
SBCD,	SIZE_B,		NUM_AREG_DEC_IND,	NUM_AREG_DEC_IND,	0x8108,	0x0000,	0,	0,	9,	FLAG_68000
#
#	Set byte according to a condition code
#
#	Note:
#		SCC has the alias SHS
#		SCS has the alias SLO
#
ST,	SIZE_B,		EA_DEST_ARG,		NO_ARGUMENT,		0x50C0,	0x0000,	0,	0,	0,	FLAG_68000
SF,	SIZE_B,		EA_DEST_ARG,		NO_ARGUMENT,		0x51C0,	0x0000,	0,	0,	0,	FLAG_68000
SHI,	SIZE_B,		EA_DEST_ARG,		NO_ARGUMENT,		0x52C0,	0x0000,	0,	0,	0,	FLAG_68000
SLS,	SIZE_B,		EA_DEST_ARG,		NO_ARGUMENT,		0x53C0,	0x0000,	0,	0,	0,	FLAG_68000
SCC,	SIZE_B,		EA_DEST_ARG,		NO_ARGUMENT,		0x54C0,	0x0000,	0,	0,	0,	FLAG_68000
SHS,	SIZE_B,		EA_DEST_ARG,		NO_ARGUMENT,		0x54C0,	0x0000,	0,	0,	0,	FLAG_68000
SCS,	SIZE_B,		EA_DEST_ARG,		NO_ARGUMENT,		0x55C0,	0x0000,	0,	0,	0,	FLAG_68000
SLO,	SIZE_B,		EA_DEST_ARG,		NO_ARGUMENT,		0x55C0,	0x0000,	0,	0,	0,	FLAG_68000
SNE,	SIZE_B,		EA_DEST_ARG,		NO_ARGUMENT,		0x56C0,	0x0000,	0,	0,	0,	FLAG_68000
SEQ,	SIZE_B,		EA_DEST_ARG,		NO_ARGUMENT,		0x57C0,	0x0000,	0,	0,	0,	FLAG_68000
SVC,	SIZE_B,		EA_DEST_ARG,		NO_ARGUMENT,		0x58C0,	0x0000,	0,	0,	0,	FLAG_68000
SVS,	SIZE_B,		EA_DEST_ARG,		NO_ARGUMENT,		0x59C0,	0x0000,	0,	0,	0,	FLAG_68000
SPL,	SIZE_B,		EA_DEST_ARG,		NO_ARGUMENT,		0x5AC0,	0x0000,	0,	0,	0,	FLAG_68000
SMI,	SIZE_B,		EA_DEST_ARG,		NO_ARGUMENT,		0x5BC0,	0x0000,	0,	0,	0,	FLAG_68000
SGE,	SIZE_B,		EA_DEST_ARG,		NO_ARGUMENT,		0x5CC0,	0x0000,	0,	0,	0,	FLAG_68000
SLT,	SIZE_B,		EA_DEST_ARG,		NO_ARGUMENT,		0x5DC0,	0x0000,	0,	0,	0,	FLAG_68000
SGT,	SIZE_B,		EA_DEST_ARG,		NO_ARGUMENT,		0x5EC0,	0x0000,	0,	0,	0,	FLAG_68000
SLE,	SIZE_B,		EA_DEST_ARG,		NO_ARGUMENT,		0x5FC0,	0x0000,	0,	0,	0,	FLAG_68000
#
#	Stop and wait for interrupt
#
STOP,	NO_SIZE,	NO_ARGUMENT,		NO_ARGUMENT,		0x4E72,	0x0000,	0,	0,	0,	FLAG_68000
#
#	Subtraction of simple numbers
#
SUB,	SIZE_BWL,	NUM_DREG,		EA_MEMORY_ARG,		0x9100,	0x0000,	6,	9,	0,	FLAG_68000
SUB,	SIZE_BWL,	EA_SOURCE_ARG,		NUM_DREG,		0x9000,	0x0000,	6,	0,	9,	FLAG_68000
SUBA,	SIZE_WL,	EA_SOURCE_ARG,		NUM_AREG,		0x90C0,	0x0000,	8,	0,	9,	FLAG_68000
SUBI,	SIZE_BWL,	EA_IMMEDIATE,		EA_DEST_ARG,		0x0400,	0x0000,	6,	APPEND,	0,	FLAG_68000
SUBQ,	SIZE_BWL,	NUM_IMMEDIATE_QUICK,	EA_DEST_ARG|EA_AREG,	0x5100,	0x0000,	6,	9,	0,	FLAG_68000
SUBX,	SIZE_BWL,	NUM_DREG,		NUM_DREG,		0x9100,	0x0000,	6,	9,	0,	FLAG_68000
SUBX,	SIZE_BWL,	NUM_AREG_DEC_IND,	NUM_AREG_DEC_IND,	0x9108,	0x0000,	6,	9,	0,	FLAG_68000
#
#	Swap words in data register
#
SWAP,	SIZE_W,		NUM_DREG,		NO_ARGUMENT,		0x4840,	0x0000,	0,	0,	0,	FLAG_68000
#
#	Test and Set a byte (in memory, presumably)
#
TAS,	SIZE_B,		EA_DEST_ARG,		NO_ARGUMENT,		0x4AC0,	0x0000,	0,	0,	0,	FLAG_68000
#
#	System call trap 0 through to 15.
#
TRAP,	NO_SIZE,	NUM_IMMEDIATE_4,	NO_ARGUMENT,		0x4E40,	0x0000,	0,	0,	0,	FLAG_68000
#
#	Execute overflow trap if V flag set.
#
TRAPV,	NO_SIZE,	NO_ARGUMENT,		NO_ARGUMENT,		0x4E76,	0x0000,	0,	0,	0,	FLAG_68000
#
#	Test the content of an Effective Address
#
TST,	SIZE_BWL,	EA_DEST_ARG,		NO_ARGUMENT,		0x4A00,	0x0000,	6,	0,	0,	FLAG_68000
#
#	Unlink a previously linked stack frame.
#
UNLK,	NO_SIZE,	NUM_AREG,		NO_ARGUMENT,		0x4E58,	0x0000,	0,	0,	0,	FLAG_68000

#
#	Motorola 68010 Opcodes
#	======================
#
MOVE,	SIZE_W,		EA_FLAGS_REG,		EA_DEST_ARG,		0x42C0,	0x0000,	0,	IGNORE,	0,	FLAG_68010
#
MOVEC,	SIZE_L,		CONTROL_REG,		NUM_DREG,		0x4E7A, 0x0000, 0, APPEND, AUX(12),	FLAG_68010
MOVEC,	SIZE_L,		CONTROL_REG,		NUM_AREG,		0x4E7A, 0x8000, 0, APPEND, AUX(12),	FLAG_68010
MOVEC,	SIZE_L,		NUM_DREG,		CONTROL_REG,		0x4E7B, 0x0000, 0, AUX(12), APPEND,	FLAG_68010
MOVEC,	SIZE_L,		NUM_AREG,		CONTROL_REG,		0x4E7B, 0x8000, 0, AUX(12), APPEND,	FLAG_68010
#
MOVES,	SIZE_BWL,	EA_MEMORY_ARG,		NUM_DREG,		0x0E00, 0x0000,	6, 	0, AUX(12),	FLAG_68010
MOVES,	SIZE_BWL,	EA_MEMORY_ARG,		NUM_AREG,		0x0E00, 0x8000,	6, 	0, AUX(12),	FLAG_68010
MOVES,	SIZE_BWL,	NUM_DREG,		EA_MEMORY_ARG,		0x0E00, 0x0800,	6, 	AUX(12), 0,	FLAG_68010
MOVES,	SIZE_BWL,	NUM_AREG,		EA_MEMORY_ARG,		0x0E00, 0x8800,	6, 	AUX(12), 0,	FLAG_68010
#
#	Return and drop parameters to routine
#
RTD,	NO_SIZE,	NUM_IMMEDIATE_16,	NO_ARGUMENT,		0x4E74, 0x0000,	0,	APPEND,	0,	FLAG_68010

#
#	Motorola 68881 Opcodes
#	======================
#


#
#	EOF
#
