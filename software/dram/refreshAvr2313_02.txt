# **Sistema Completo de Refresh DRAM + Acesso da CPU com D√©bitos**  

Agora vamos implementar **tudo em um √∫nico circuito**:  
‚úÖ **Refresh autom√°tico** (RAS-only)  
‚úÖ **Controle de d√©bitos** (se a CPU monopolizar o barramento)  
‚úÖ **Acesso concorrente da CPU √† DRAM**  
‚úÖ **Arbitragem de barramento**  

---

## **üì° Diagrama do Circuito Completo**
```
  +---------------------+
  | AT90S2313           |
  |                     |
  | PB0-PB7 ----+       |---> A0-A7 DRAM
  |             |       |
  | PD0 (OC1A) -+-> RAS |
  | PD1 (OC1B) -+-> CAS |
  | PD2 (INT0) <- CPU_REQUEST
  | PD3 (T1) <-- CLOCK_DRAM (opcional)
  +---------------------+
         |
         v
  +---------------------+
  | L√≥gica de Arbitragem|
  | (74HC00 + 74HC32)   |
  +---------------------+
         |
         v
  +---------------------+
  | DRAM (41256, etc.)  |
  +---------------------+
```

---

## **üîß Componentes Adicionais**
| Componente          | Fun√ß√£o                                  |
|---------------------|----------------------------------------|
| 74HC00 (NAND)       | L√≥gica de controle RAS/CAS             |
| 74HC32 (OR)         | Arbitragem CPU vs Refresh              |
| 74HC245 (Opcional)  | Buffer bidirecional se CPU compartilhar dados |

---

## **üìå Firmware Completo (Acesso CPU + D√©bitos)**
```c
#include <avr/io.h>
#include <avr/interrupt.h>
#include <util/delay.h>

// Configura√ß√µes
#define REFRESH_INTERVAL_US    15   // 15Œºs entre refreshes
#define MAX_REFRESH_DEBT       4    // M√°ximo de refreshes pendentes

// Vari√°veis
volatile uint8_t refresh_debt = 0;
volatile uint8_t current_row = 0;
volatile uint8_t cpu_accessing = 0;

// Interrup√ß√£o do Timer1 (Refresh)
ISR(TIMER1_COMPA_vect) {
    if (!cpu_accessing) {
        // Modo Refresh Normal
        PORTB = current_row;      // Envia endere√ßo
        PORTD &= ~(1 << PD0);     // Ativa RAS
        _delay_us(0.1);
        PORTD |= (1 << PD0);      // Desativa RAS
        current_row++;
        if (refresh_debt > 0) refresh_debt--;
    } 
    else {
        // CPU est√° acessando ‚Üí acumula d√©bito
        if (refresh_debt < MAX_REFRESH_DEBT) refresh_debt++;
    }

    // Refresh For√ßado se d√©bito >= MAX_REFRESH_DEBT
    if (refresh_debt >= MAX_REFRESH_DEBT) {
        force_refresh();
    }
}

// For√ßa um refresh (ignora acesso da CPU)
void force_refresh() {
    cli();
    DDRB = 0xFF;              // Assume controle do barramento
    PORTB = current_row;      // Envia endere√ßo
    PORTD &= ~(1 << PD0);     // RAS ativo
    _delay_us(0.1);
    PORTD |= (1 << PD0);      // RAS inativo
    current_row++;
    refresh_debt--;
    sei();
}

// Interrup√ß√£o INT0 (CPU_REQUEST)
ISR(INT0_vect) {
    if (PIND & (1 << PD2)) {
        cpu_accessing = 0;    // CPU liberou o barramento
        DDRB = 0xFF;         // AT90 retoma controle
    } 
    else {
        cpu_accessing = 1;    // CPU est√° acessando
        DDRB = 0x00;          // AT90 entra em alta imped√¢ncia
    }
}

// Configura√ß√µes iniciais
void setup() {
    // I/O
    DDRB = 0xFF;              // PB = sa√≠da (endere√ßos)
    DDRD = (1 << PD0) | (1 << PD1); // PD0 = RAS, PD1 = CAS
    PORTD |= (1 << PD0);      // RAS inativo (alto)

    // Interrup√ß√£o INT0 (CPU_REQUEST)
    GIMSK |= (1 << INT0);     // Habilita INT0
    MCUCR |= (1 << ISC00);    // Qualquer mudan√ßa em PD2 gera INT

    // Timer1 (Refresh autom√°tico)
    TCCR1A = 0;
    TCCR1B = (1 << WGM12) | (1 << CS10); // CTC, prescaler = 1
    OCR1A = (F_CPU / 1000000) * REFRESH_INTERVAL_US - 1;
    TIMSK |= (1 << OCIE1A);   // Habilita interrup√ß√£o

    sei(); // Habilita interrup√ß√µes globais
}

int main() {
    setup();
    while (1) { } // Tudo √© tratado por interrup√ß√µes
}
```

---

## **‚öôÔ∏è Funcionamento Detalhado**

### **1. Acesso da CPU √† DRAM**
- Quando a CPU precisa acessar a DRAM:
  - **CPU_REQUEST vai para LOW** (aciona INT0).
  - O AT90 **coloca PB0-PB7 em alta imped√¢ncia** (`DDRB = 0x00`).
  - A CPU controla **RAS, CAS e endere√ßos diretamente**.

### **2. Sistema de D√©bitos**
- Se a CPU fica muito tempo no barramento:
  - O Timer1 continua contando e **aumenta `refresh_debt`**.
  - Se `refresh_debt >= MAX_REFRESH_DEBT`, o AT90 **for√ßa um refresh** (`force_refresh()`), mesmo durante acesso da CPU.

### **3. Retorno ao Refresh Autom√°tico**
- Quando **CPU_REQUEST volta para HIGH**:
  - A interrup√ß√£o INT0 **reativa o controle do AT90** (`DDRB = 0xFF`).
  - O sistema volta ao **refresh normal**.

---

## **üìå Conclus√£o**
Este circuito **garante**:  
‚úÖ **Refresh correto da DRAM** (mesmo com CPU acessando).  
‚úÖ **Baixo custo** (apenas AT90 + pouca l√≥gica discreta).  
‚úÖ **Controle de d√©bitos** (evita perda de dados).  

**Pronto para integrar em sistemas com DRAM antiga!** üöÄ
