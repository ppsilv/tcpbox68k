# **Circuito Completo de Refresh DRAM com AT90S2313 ‚Äì Programa e Hardware Otimizado**  

Neste artigo, vamos projetar um **controlador de refresh DRAM totalmente aut√¥nomo** usando um **AT90S2313** (ou ATtiny2313) para gerenciar:  
‚úÖ **Refresh autom√°tico** (RAS-only)  
‚úÖ **Controle de d√©bitos** (se a CPU monopolizar o barramento)  
‚úÖ **Alta imped√¢ncia quando a CPU acessa a mem√≥ria**  

---

## **üîß Componentes Necess√°rios**
| Componente          | Fun√ß√£o                                  |
|---------------------|----------------------------------------|
| AT90S2313 / ATtiny2313 | Gerencia refresh e d√©bitos             |
| Resistores 100Œ©     | Prote√ß√£o das sa√≠das (opcional)         |
| Capacitor 100nF     | Filtro de ru√≠do (VCC-GND)              |
| Cristal 7.3728MHz   | Clock preciso para temporiza√ß√£o        |

---

## **üì° Diagrama do Circuito**  
```
  +---------------------+
  | AT90S2313           |
  |                     |
  | PB0-PB7 ------------|---> A0-A7 DRAM (endere√ßos de linha)
  | PD0 (OC1A) ---------|---> RAS (pulso de refresh)
  | PD2 (INT0) <--------|----- CPU_REQUEST (sinal da CPU)
  +---------------------+
```

### **üîå Conex√µes Essenciais:**
- **PB0-PB7** ‚Üí **A0-A7 da DRAM** (endere√ßos de linha para refresh).  
- **PD0 (OC1A)** ‚Üí **RAS** (pulso ativo em n√≠vel baixo).  
- **PD2 (INT0)** ‚Üê **CPU_REQUEST** (n√≠vel baixo = CPU est√° acessando a DRAM).  

---

## **üíæ Firmware Completo (AVR GCC)**
```c
#include <avr/io.h>
#include <avr/interrupt.h>
#include <util/delay.h>

// Defini√ß√µes
#define REFRESH_INTERVAL_US    15   // 15Œºs entre refreshes (416 em 2ms)
#define MAX_REFRESH_DEBT       4    // M√°ximo de refreshes pendentes

// Vari√°veis globais
volatile uint8_t refresh_debt = 0;
volatile uint8_t current_row = 0;

// Interrup√ß√£o do Timer1 (refresh autom√°tico)
ISR(TIMER1_COMPA_vect) {
    if (!(PIND & (1 << PD2))) {  // Se CPU n√£o est√° acessando
        // Gera pulso RAS
        PORTB = current_row;      // Envia endere√ßo da linha
        PORTD &= ~(1 << PD0);     // RAS ativo (baixo)
        _delay_us(0.1);           // 100ns de pulso (ajust√°vel)
        PORTD |= (1 << PD0);      // RAS inativo (alto)
        
        current_row++;            // Pr√≥xima linha
        if (refresh_debt > 0) refresh_debt--; // Reduz d√©bito
    } 
    else {
        // CPU est√° acessando ‚Üí acumula d√©bito
        if (refresh_debt < MAX_REFRESH_DEBT) refresh_debt++;
    }

    // For√ßa refresh se d√©bito atingir limite
    if (refresh_debt >= MAX_REFRESH_DEBT) {
        force_refresh();
    }
}

// For√ßa um refresh (mesmo com CPU acessando)
void force_refresh() {
    cli();  // Desabilita interrup√ß√µes (evita conflito)
    
    PORTB = current_row;      // Envia endere√ßo
    PORTD &= ~(1 << PD0);     // Ativa RAS
    _delay_us(0.1);
    PORTD |= (1 << PD0);      // Desativa RAS
    
    current_row++;
    refresh_debt--;
    
    sei();  // Reabilita interrup√ß√µes
}

// Configura Timer1 para gerar interrup√ß√£o a cada 15Œºs
void setup_timer1() {
    TCCR1A = 0;                     // Modo normal
    TCCR1B = (1 << WGM12) | (1 << CS10); // CTC, prescaler = 1
    OCR1A = (F_CPU / 1000000) * REFRESH_INTERVAL_US - 1; // 15Œºs
    TIMSK = (1 << OCIE1A);          // Habilita interrup√ß√£o
}

// Configura I/O
void setup_io() {
    DDRB = 0xFF;    // PB0-PB7 como sa√≠da (endere√ßos)
    DDRD = (1 << PD0); // PD0 (RAS) como sa√≠da
    PORTD |= (1 << PD0); // RAS inativo (alto)
    
    // PD2 (INT0) como entrada (CPU_REQUEST)
    DDRD &= ~(1 << PD2);
    PORTD |= (1 << PD2); // Pull-up ativado
}

int main() {
    setup_io();
    setup_timer1();
    sei(); // Habilita interrup√ß√µes globais

    while (1) {
        // Se CPU acessando, coloca barramento em alta imped√¢ncia
        if (PIND & (1 << PD2)) {
            DDRB = 0x00; // PB0-PB7 como entrada (alta imped√¢ncia)
        } else {
            DDRB = 0xFF; // PB0-PB7 como sa√≠da (controle DRAM)
        }
    }
}
```

---

## **‚öôÔ∏è Funcionamento Detalhado**
1. **Refresh Autom√°tico (RAS-only)**  
   - O **Timer1** gera interrup√ß√µes a cada **15Œºs** (416 refreshes em 2ms).  
   - O AT90 envia um **endere√ßo de linha (PB0-PB7)** e gera um **pulso RAS (PD0)**.  

2. **Controle de D√©bitos**  
   - Se a **CPU acessa a DRAM (CPU_REQUEST = 0)**, o refresh √© **adiado** e o d√©bito aumenta.  
   - Se o d√©bito atinge **MAX_REFRESH_DEBT (4)**, o AT90 **for√ßa um refresh**, mesmo durante acesso da CPU.  

3. **Alta Imped√¢ncia Quando a CPU Controla a DRAM**  
   - Se **CPU_REQUEST = 0**, o AT90 **desativa as sa√≠das (DDRB = 0x00)**, liberando o barramento.  

---

## **üìå Conclus√£o**
Este projeto **elimina componentes desnecess√°rios** (latches, buffers) e usa apenas:  
‚úî **Um AT90S2313**  
‚úî **Resistores de prote√ß√£o (opcional)**  
‚úî **Cristal para clock preciso**  

### **üîπ Vantagens:**
‚úÖ **Baixo custo** (apenas o microcontrolador + poucos componentes)  
‚úÖ **Controle preciso** (temporiza√ß√£o ajust√°vel via software)  
‚úÖ **Funcionamento aut√¥nomo** (n√£o depende da CPU para refresh)  

**Pronto para usar em sistemas com DRAM antiga (416 refresh/2ms)!** üöÄ
