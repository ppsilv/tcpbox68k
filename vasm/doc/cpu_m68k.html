<!DOCTYPE html>
<html>
<!-- Created by GNU Texinfo 7.1, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Untitled Document</title>

<meta name="description" content="Untitled Document">
<meta name="keywords" content="Untitled Document">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
span:hover a.copiable-link {visibility: visible}
ul.mark-minus {list-style-type: "\2212"}
-->
</style>


</head>

<body lang="en">
<p>This chapter documents the backend for the Motorola M68k/CPU32/ColdFire
microprocessor family.
</p>
<div class="section-level-extent" id="Legal">
<h3 class="section"><span>1 Legal<a class="copiable-link" href="#Legal"> &para;</a></span></h3>

<p>This module is written in 2002-2024 by Frank Wille and
    is covered by the vasm copyright without modifications.
</p>

</div>
<div class="section-level-extent" id="Additional-options-for-this-module">
<h3 class="section"><span>2 Additional options for this module<a class="copiable-link" href="#Additional-options-for-this-module"> &para;</a></span></h3>

<p>Note, that the order on the command line may be important when specifying
options. For example, if you specify <samp class="option">-devpac</samp> compatibility
mode behind enabling some optimization options, the Devpac-mode might
disable these optimizations again.
</p>
<p>This module provides the following additional options:
</p>
<ul class="mini-toc">
<li><a href="#CPU-selections" accesskey="1">CPU selections</a></li>
<li><a href="#Optimization-options" accesskey="2">Optimization options</a></li>
<li><a href="#Other-options" accesskey="3">Other options</a></li>
</ul>
<div class="subsection-level-extent" id="CPU-selections">
<h4 class="subsection"><span>2.1 CPU selections<a class="copiable-link" href="#CPU-selections"> &para;</a></span></h4>
<dl class="table">
<dt><samp class="option">-m68000</samp></dt>
<dd><p>Generate code for the MC68000 CPU (default).
</p>
</dd>
<dt><samp class="option">-m68008</samp></dt>
<dd><p>Generate code for the MC68008 CPU.
</p>
</dd>
<dt><samp class="option">-m68010</samp></dt>
<dd><p>Generate code for the MC68010 CPU.
</p>
</dd>
<dt><samp class="option">-m68020</samp></dt>
<dd><p>Generate code for the MC68020 CPU.
</p>
</dd>
<dt><samp class="option">-m68030</samp></dt>
<dd><p>Generate code for the MC68030 CPU.
</p>
</dd>
<dt><samp class="option">-m68040</samp></dt>
<dd><p>Generate code for the MC68040 CPU.
</p>
</dd>
<dt><samp class="option">-m68060</samp></dt>
<dd><p>Generate code for the MC68060 CPU.
</p>
</dd>
<dt><samp class="option">-m68020up</samp></dt>
<dd><p>Generate code for the MC68020-68060 CPU. Be careful with
        instructions like <code class="code">PFLUSHA</code>, which exist on 68030 and 68040/060
        with a different opcode (vasm will use the 040/060 version).
</p>
</dd>
<dt><samp class="option">-m68080</samp></dt>
<dd><p>Generate code for the Apollo Core AC68080 CPU.
        Note, that using register banking (using AMMX registers instead of
        <code class="code">d0</code> - <code class="code">d7</code> or <code class="code">a0</code> - <code class="code">a7</code>) in general purpose
        instructions might not yet work correctly with current Apollo Cores
        (at least up to 2024). This will change with future Core releases.
        Register banking for FPU instructions should be final already.
</p>
</dd>
<dt><samp class="option">-mcpu32</samp></dt>
<dd><p>Generate code for the CPU32 family (MC6833x, MC6834x, etc.).
</p>
</dd>
<dt><samp class="option">-mcf5...</samp></dt>
<dt><samp class="option">-m5...</samp></dt>
<dd><p>Generate code for a ColdFire family CPU. The following types are
        recognized: 5202, 5204, 5206, 520x, 5206e, 5207, 5208, 5210a, 5211a,
        5212, 5213, 5214, 5216, 5224, 5225, 5232, 5233, 5234, 5235, 523x,
        5249, 5250, 5253, 5270, 5271, 5272, 5274, 5275, 5280, 5281, 528x,
        52221, 52553, 52230, 52231, 52232, 52233, 52234, 52235, 52252,
        52254, 52255, 52256, 52258, 52259, 52274, 52277,
        5307, 5327, 5328, 5329, 532x, 5372, 5373, 537x, 53011, 53012, 53013,
        53014, 53015, 53016, 53017, 5301x,
        5407, 5470, 5471, 5472, 5473, 5474, 5475, 547x, 5480, 5481, 5482,
        5483, 5484, 5485, 548x, 54450, 54451, 54452, 54453, 5445x.
</p>
</dd>
<dt><samp class="option">-mcfv2</samp></dt>
<dd><p>Generate code for the V2 ColdFire core. This option selects
        ISA_A (no hardware division or MAC), which is the most limited ISA
        supported by 5202, 5204 and 5206. All other ColdFire chips are
        backwards compatible to V2.
</p>
</dd>
<dt><samp class="option">-mcfv3</samp></dt>
<dd><p>Generate code for the V3 ColdFire core. This option selects
        ISA_A+, hardware division MAC and EMAC instructions, which are
        supported by nearly all V3 CPUs, except the 5307.
</p>
</dd>
<dt><samp class="option">-mcfv4</samp></dt>
<dd><p>Generate code for the V4 ColdFire core. This option selects ISA_B
        and MAC as supported by the 5407.
</p>
</dd>
<dt><samp class="option">-mcfv4e</samp></dt>
<dd><p>Generate code for the V4e ColdFire core. This option selects ISA_B,
        USP-, FPU-, MAC- and EMAC-instructions (no hardware division) as
        supported by all 547x and 548x CPUs.
</p>
</dd>
<dt><samp class="option">-m68851</samp></dt>
<dd><p>Generate code for the MC68851 MMU. May be used in combination
        with another <samp class="option">-m</samp> option.
</p>
</dd>
<dt><samp class="option">-m68881</samp></dt>
<dd><p>Generate code for the MC68881 FPU. May be used in combination
        with another <samp class="option">-m</samp> option.
</p>
</dd>
<dt><samp class="option">-m68882</samp></dt>
<dd><p>Generate code for the MC68882 FPU. May be used in combination
        with another <samp class="option">-m</samp> option.
</p>
</dd>
<dt><samp class="option">-no-fpu</samp></dt>
<dd><p>Ignore any FPU options or directives, which has the effect that
        no 68881/2 FPU instructions will be accepted. This option can
        override the default behaviour of <samp class="option">-gas</samp> enabling the FPU.
</p></dd>
</dl>

</div>
<div class="subsection-level-extent" id="Optimization-options">
<h4 class="subsection"><span>2.2 Optimization options<a class="copiable-link" href="#Optimization-options"> &para;</a></span></h4>
<dl class="table">
<dt><samp class="option">-no-opt</samp></dt>
<dd><p>Disable all optimizations. Can be seen as a main switch to ignore
        all other optimization options on the command line and in the source.
</p>
</dd>
<dt><samp class="option">-opt-allbra</samp></dt>
<dd><p>When specified the assembler will also try to optimize branch
        instructions which already have a valid size extension.
        This option is automatically enabled in <samp class="option">-phxass</samp> mode.
</p>
</dd>
<dt><samp class="option">-opt-brajmp</samp></dt>
<dd><p>Translate relative branch instructions, whose destination is in a
        different section, into absolute jump instructions.
</p>
</dd>
<dt><samp class="option">-opt-clr</samp></dt>
<dd><p>Enables optimization from <code class="code">MOVE #0,&lt;ea&gt;</code> into <code class="code">CLR &lt;ea&gt;</code>
        for the MC68000. Note that <code class="code">CLR</code> will execute a read-modify-write
        cycle on the 68000, so it is disabled by default. With 68010 and
        higher this is a generic standard optimization.
</p>
</dd>
<dt><samp class="option">-opt-div</samp></dt>
<dd><p>Unsigned immediate divisors, which are a power of two (from 2 to 256),
        are optimized to shifts. Divisions by 1 are replaced by <code class="code">TST.L Dn</code>
        (32-bit) or <code class="code">MVZ.W Dn,Dn</code> (16-bit, ColdFire only). Divisions by
        -1 are replaced by <code class="code">NEG.L Dn</code> (32-bit) or by a combination of
        <code class="code">NEG.W Dn</code> and <code class="code">MVZ.W Dn,Dn</code> (16-bit, ColdFire only).
        This optimization will leave the flags in a different state as
        can normally be expected after a division instruction.
</p>
</dd>
<dt><samp class="option">-opt-fconst</samp></dt>
<dd><p>Floating point constants are loaded with the lowest precision
        possible. This means that <code class="code">FMOVE.D #1.0,FP0</code> would be
        optimized to <code class="code">FMOVE.S #1.0,FP0</code>, or even <code class="code">FMOVE.W #1,FP0</code>,
        because it is faster and shorter at the same precision.
        The optimization will be performed on all FPU instructions with
        immediate addressing mode.
        When an FDIV-family instruction (<code class="code">FSDIV</code>, <code class="code">FDDIV</code>,
        <code class="code">FSGLDIV</code>) is detected it will additionally be checked if the
        immediate constant is a power of 2 and then converted into
        <code class="code">FMUL #1/c,FPn</code>.
</p>
</dd>
<dt><samp class="option">-opt-jbra</samp></dt>
<dd><p><code class="code">JMP</code> and <code class="code">JSR</code> instructions to external labels will be
        converted into <code class="code">BRA.L</code> and <code class="code">BSR.L</code>, when the selected
        CPU is 68020 or higher (or CPU32).
</p>
</dd>
<dt><samp class="option">-opt-lsl</samp></dt>
<dd><p>Allows optimization of <code class="code">LSL #1</code> into <code class="code">ADD</code>. It is also
        needed to optimize <code class="code">ASL #2</code> and <code class="code">LSL #2</code> into two <code class="code">ADD</code>
        instructions (together with <samp class="option">-opt-speed</samp>).
        These optimizations can modify the V-flag, which may not be intended.
</p>
</dd>
<dt><samp class="option">-opt-movem</samp></dt>
<dd><p>Enables optimization from <code class="code">MOVEM &lt;ea&gt;,Rn</code> into
        <code class="code">MOVE &lt;ea&gt;,Rn</code> (or the other way around). May also optimize
        <code class="code">MOVEM</code> with two registers into two separate <code class="code">MOVE</code>
        insructions, when advantageous for the currently selected CPU.
        This optimization will modify the flags when the destination is
        no address register.
</p>
</dd>
<dt><samp class="option">-opt-mul</samp></dt>
<dd><p>Immediate multplication factors, which are a power of two (from 2
        to 256), are optimized to shifts. Multiplications with zero are
        replaced by a <code class="code">MOVEQ #0,Dn</code>, with -1 are replaced by a
        <code class="code">NEG.L Dn</code> and with 1 by <code class="code">EXT.L Dn</code> or <code class="code">TST.L Dn</code>
        (long-form). Not all optimizations are available for all cpu types
        (e.g. <code class="code">MULU.W</code> can only be optimized on ColdFire by using
        the <code class="code">MVZ.W</code> instruction).
        This optimization will leave the flags in a different state as
        can normally be expected after a multiplication instruction, and
        the size of the optimized code may be bigger than before in some
        situations (e.g. <code class="code">MULS.W #4,Dn</code>). So the latter will additionally
        require the <samp class="option">-opt-speed</samp> flag.
</p>
</dd>
<dt><samp class="option">-opt-nmoveq</samp></dt>
<dd><p>Optimizes <code class="code">MOVE.L #x,Dn</code> into a combination of <code class="code">MOVEQ</code>
        and <code class="code">NEG.W</code>, which works for ranges from
        <code class="code">$ff81&lt;=x&lt;=$ffff</code> and <code class="code">$ffff0001&lt;=x&lt;=$ffff0080</code>.
        Note that this optimization flips the N-flag!
</p>
</dd>
<dt><samp class="option">-opt-pea</samp></dt>
<dd><p>Enables optimization from <code class="code">MOVE #x,-(SP)</code> into <code class="code">PEA x</code>.
        This optimization will leave the flags unmodified, which might
        not be intended.
</p>
</dd>
<dt><samp class="option">-opt-size</samp></dt>
<dd><p>Optimize for size, even if this would make the code slower.
        This enables for example optimization of <code class="code">MOVE.L #x,Dn</code>
        into <code class="code">MOVEQ #x&gt;&gt;n,Dn + LSL.W #n,Dn</code>. It is mostly used
        together with other optimization flags.
</p>
</dd>
<dt><samp class="option">-opt-speed</samp></dt>
<dd><p>Optimize for speed, even if this would increase code size.
        For example it enables optimization of <code class="code">ASL.W #2,Dn</code> into two
        <code class="code">ADD.W Dn,Dn</code> instructions. Or <code class="code">MULS.W #-4,Dn</code> into
        <code class="code">EXT.L Dn + ASL.L #2,Dn + NEG.L Dn</code>.
</p>
</dd>
<dt><samp class="option">-opt-st</samp></dt>
<dd><p>Enables optimization from <code class="code">MOVE.B #-1,&lt;ea&gt;</code> into <code class="code">ST &lt;ea&gt;</code>.
        This optimization will leave the flags unmodified, which might
        not be intended.
</p>
</dd>
<dt><samp class="option">-opt-&lt;option&gt;</samp></dt>
<dd><p>Alternatively, you can use <samp class="option">-opt-</samp> followed by a
        Devpac-compatible option, as described under the <code class="code">OPT</code>
        directive. Example: <samp class="option">-opt-o1-</samp> disables branch optimization
        in the same way as an <code class="code">OPT o1-</code> directive would do at the
        top of the source text.
</p>
</dd>
<dt><samp class="option">-sc</samp></dt>
<dd><p>Small code model.
        All <code class="code">JMP</code> and <code class="code">JSR</code> instructions to external labels
        will be converted into 16-bit PC-relative jumps.
</p>
</dd>
<dt><samp class="option">-sd</samp></dt>
<dd><p>References to labels in a
        small data section (named &quot;__MERGED&quot;) are optimized into
        base-relative addressing mode, using the current base register set
        by an active <code class="code">NEAR</code> directive.
        This option is automatically enabled in <samp class="option">-phxass</samp> mode.
</p>
</dd>
<dt><samp class="option">-showcrit</samp></dt>
<dd><p>Print all critical optimizations which have side effects. Among
        those are <samp class="option">-opt-lsl</samp>, <samp class="option">-opt-mul</samp>, <samp class="option">-opt-st</samp>,
        <samp class="option">-opt-pea</samp>, <samp class="option">-opt-movem</samp> and <samp class="option">-opt-clr</samp>.
</p>
</dd>
<dt><samp class="option">-showopt</samp></dt>
<dd><p>Print all optimizations and translations vasm is doing
        (same as <code class="code">opt ow+</code>).
</p>
</dd>
<dt><samp class="option">-warnabs16</samp></dt>
<dd><p>Show a warning for every access to an absolute 16-bit address.
</p>
</dd>
<dt><samp class="option">-warnabs32</samp></dt>
<dd><p>Show a warning for every access to an absolute 32-bit address.
        This doesn&rsquo;t include section labels.
</p></dd>
</dl>

<p>In its default setting (no <samp class="option">-devpac</samp> or <samp class="option">-phxass</samp> option)
vasm performs the following optimizations:
</p><ul class="itemize mark-minus">
<li>Absolute to PC-relative.
</li><li>Branches without explicit size.
</li><li>Displacements (32 to 16 bit, <code class="code">(0,An)</code> to <code class="code">(An)</code>, etc).
</li><li>Optimize floating point constants to the lowest possible precision.
</li><li>Many instruction optimizations which are safe.
</li></ul>

</div>
<div class="subsection-level-extent" id="Other-options">
<h4 class="subsection"><span>2.3 Other options<a class="copiable-link" href="#Other-options"> &para;</a></span></h4>
<dl class="table">
<dt><samp class="option">-conv-brackets</samp></dt>
<dd><p>Brackets (<code class="code">'['</code> and <code class="code">']'</code>) in an operand are automatically
        treated like parentheses (<code class="code">'('</code> and <code class="code">')'</code>) as long as
        the CPU is 68000 or 68010. This is a compatibility option for some
        old assemblers.
</p>
</dd>
<dt><samp class="option">-devpac</samp></dt>
<dd><p>All options are initially set to be Devpac compatible. Which means
        that all optimizations are disabled, no debugging symbols will be
        written and vasm will warn about any optimization being done.
        When symbol output is enabled by <code class="code">opt d+</code>, then the TOS symbol
        table defaults to standard DRI format (limited to 8 characters).
        Shift-right operations are performed using an unsigned 32-bit value.
        Other options are the same as vasm&rsquo;s defaults.
        The symbol <code class="code">__G2</code> is defined, which contains information
        about the selected cpu type.
        The symbol <code class="code">__LK</code> reflects the type of output file to generate.
        Which is 0 for TOS executables, 1 for DRI objects, 2 for GST objects,
        3 for AmigaDOS objects and 4 for AmigaDOS executables.
        All other formats are represented by 99, as they are unknown to Devpac.
        It will also automatically enable <samp class="option">-guess-ext</samp> and
        <samp class="option">-nodpc</samp>.
</p>
</dd>
<dt><samp class="option">-elfregs</samp></dt>
<dd><p>Register names have to be prefixed by a &rsquo;%&rsquo; to prevent confusion
        with symbol names.
</p>
</dd>
<dt><samp class="option">-extsd</samp></dt>
<dd><p>Recognize small data references in all 020+ extended addressing modes
        using 16-bit displacements on the base register. By default only the
        16-bit address register displacement addressing mode can be used
        with small data (for compatibility reasons).
</p>
</dd>
<dt><samp class="option">-gas</samp></dt>
<dd><p>Enable additional GNU-as compatibility mnemonics, like
        <code class="code">mov</code>, <code class="code">movm</code> and <code class="code">jra</code>. Also accepts <code class="code">|</code>
        instead of <code class="code">;</code> for comments.
        GNU-as compatibility mode selects the 68020 CPU and 68881/2 FPU
        by default and enables <samp class="option">-opt-jbra</samp>.
</p>
</dd>
<dt><samp class="option">-guess-ext</samp></dt>
<dd><p>Accept illegal size extensions for an instruction, as long as
        the instruction is unsized or there is just a single size possible.
        This is the default setting in PhxAss and Devpac compatibility mode.
</p>
</dd>
<dt><samp class="option">-kick1hunks</samp></dt>
<dd><p>Prevents optimization of JMP/JSR to 32-bit PC-relative (BRA/BSR),
        which requires a relocation type that is missing for Kickstart 1.x.
</p>
</dd>
<dt><samp class="option">-nodpc</samp></dt>
<dd><p>Do not attempt to encode absolute PC-displacements directly.
        Example: <code class="code">10(PC)</code>
</p>
</dd>
<dt><samp class="option">-no-typechk</samp></dt>
<dd><p>Do not check the size and type of expressions (<code class="code">OPT t-</code>).
        Example: <code class="code">dc.b 300</code>
</p>
</dd>
<dt><samp class="option">-phxass</samp></dt>
<dd><p>PhxAss-compatibilty mode. The &quot;current PC symbol&quot; (e.g. <code class="code">*</code> in
        mot-syntax module) is set to the instruction&rsquo;s address + 2 whenever
        an instruction is parsed.
        According to the current cpu setting the symbols <code class="code">__CPU</code>,
        <code class="code">__FPU</code> and <code class="code">__MMU</code> are defined.
        <code class="code">JMP/JSR (label,PC)</code> will never be optimized (into a branch,
        for example).
        It will also automatically enable <samp class="option">-opt-allbra</samp>,
        <samp class="option">-sd</samp> and <samp class="option">-guess-ext</samp>.
</p>
</dd>
<dt><samp class="option">-rangewarnings</samp></dt>
<dd><p>Recognized for backwards-compatibility only.
        No longer needed since V2.0.
</p>
</dd>
<dt><samp class="option">-regsymredef</samp></dt>
<dd><p>Allow redefining register symbols with <code class="code">EQUR</code>. This should
        only be used for compatibility with old sources. Not many assemblers
        support that.
</p>
</dd>
<dt><samp class="option">-sdreg=&lt;n&gt;</samp></dt>
<dd><p>Set the small data base register to <code class="code">An</code>. &lt;n&gt; is valid
        between 0 and 6.
</p>
</dd>
<dt><samp class="option">-sgs</samp></dt>
<dd><p>Additionally allow immediate operands to be prefixed by
        <code class="code">&amp;</code> instead of just by <code class="code">#</code>. This syntax was used by
        the SGS assembler.
</p></dd>
</dl>

</div>
</div>
<div class="section-level-extent" id="General">
<h3 class="section"><span>3 General<a class="copiable-link" href="#General"> &para;</a></span></h3>

<p>This backend accepts M68k and CPU32 instructions as described in
Mototola&rsquo;s M68000 family Programmer&rsquo;s Reference Manual. Additionally
it supports ColdFire instructions as described in Motorola&rsquo;s ColdFire
Microprocessor Family Programmer&rsquo;s Reference Manual.
</p>
<p>The syntax for the scale factor in ColdFire <code class="code">MAC</code> instructions is
<code class="code">&lt;&lt;</code> for left- and <code class="code">&gt;&gt;</code> for right-shift. The scale factor may be
appended as an optional operand, when needed.
Example: <code class="code">mac d0.l,d1.u,&lt;&lt;</code>.
</p>
<p>The mask flag in <code class="code">MAC</code> instructions is written as <code class="code">&amp;</code> and is
appended directly to the effective address operand. Example:
<code class="code">mac d0,d1,(a0)&amp;,d2</code>.
</p>
<p>The register list in <code class="code">MOVEM</code>, <code class="code">FMOVEM</code>, etc. instructions
may optionally be specified by an immediate addressing mode, using a
16 or 8 (<code class="code">FMOVEM</code>) bit register mask constant.
Example (push no registers): <code class="code">movem.l #0,-(sp)</code>.
</p>
<p>The target address type is 32 bit. Floating point constants in
instructions and data are supported and encoded in IEEE format.
</p>
<p>Default alignment for instructions is 2 bytes. The default alignment for
data is 2 bytes, when the data size is larger than 8 bits. Note, that
data is not auto-aligned unless you specify the <samp class="option">-align</samp> option
(or use Devpac-compatibility mode: <samp class="option">-devpac</samp>).
</p>
</div>
<div class="section-level-extent" id="Internal-symbols">
<h3 class="section"><span>4 Internal symbols<a class="copiable-link" href="#Internal-symbols"> &para;</a></span></h3>

<p>Depending on the selected cpu type the <code class="code">__VASM</code> symbol will have
a value defined by the following bits:
</p><dl class="table">
<dt><code class="code">bit 0</code></dt>
<dd><p>MC68000 instruction set. Also used by MC6830x, MC68322, MC68356.
</p></dd>
<dt><code class="code">bit 1</code></dt>
<dd><p>MC68010 instruction set.
</p></dd>
<dt><code class="code">bit 2</code></dt>
<dd><p>MC68020 instruction set.
</p></dd>
<dt><code class="code">bit 3</code></dt>
<dd><p>MC68030 instruction set.
</p></dd>
<dt><code class="code">bit 4</code></dt>
<dd><p>MC68040 instruction set.
</p></dd>
<dt><code class="code">bit 5</code></dt>
<dd><p>MC68060 instruction set.
</p></dd>
<dt><code class="code">bit 6</code></dt>
<dd><p>MC68881 or MC68882 FPU.
</p></dd>
<dt><code class="code">bit 7</code></dt>
<dd><p>MC68851 PMMU.
</p></dd>
<dt><code class="code">bit 8</code></dt>
<dd><p>CPU32. Any MC6833x or MC6834x CPU.
</p></dd>
<dt><code class="code">bit 9</code></dt>
<dd><p>ColdFire ISA_A.
</p></dd>
<dt><code class="code">bit 10</code></dt>
<dd><p>ColdFire ISA_A+.
</p></dd>
<dt><code class="code">bit 11</code></dt>
<dd><p>ColdFire ISA_B.
</p></dd>
<dt><code class="code">bit 12</code></dt>
<dd><p>ColdFire ISA_C.
</p></dd>
<dt><code class="code">bit 13</code></dt>
<dd><p>ColdFire hardware division support.
</p></dd>
<dt><code class="code">bit 14</code></dt>
<dd><p>ColdFire MAC instructions.
</p></dd>
<dt><code class="code">bit 15</code></dt>
<dd><p>ColdFire enhanced MAC instructions.
</p></dd>
<dt><code class="code">bit 16</code></dt>
<dd><p>ColdFire USP register.
</p></dd>
<dt><code class="code">bit 17</code></dt>
<dd><p>ColdFire FPU instructions.
</p></dd>
<dt><code class="code">bit 18</code></dt>
<dd><p>ColdFire MMU instructions.
</p></dd>
<dt><code class="code">bit 20</code></dt>
<dd><p>Apollo Core AC68080 instruction set.
</p></dd>
</dl>

<p>The following symbols are defined for compatibility with other assemblers,
so their function is not described here.
</p><dl class="table">
<dt>Devpac</dt>
<dd><p><code class="code">__G2</code>, <code class="code">__LK</code>
</p></dd>
<dt>PhxAss</dt>
<dd><p><code class="code">__CPU</code>, <code class="code">__FPU</code>, <code class="code">__MMU</code>, <code class="code">__OPTC</code>
</p></dd>
<dt>BAsm</dt>
<dd><p><code class="code">_MOVEMBYTES</code>, <code class="code">__MOVEMREGS</code>
</p></dd>
</dl>

</div>
<div class="section-level-extent" id="Extensions">
<h3 class="section"><span>5 Extensions<a class="copiable-link" href="#Extensions"> &para;</a></span></h3>

<p>This backend extends the selected syntax module by the following
directives:
</p>
<dl class="table">
<dt><code class="code">.sdreg &lt;An&gt;</code></dt>
<dd><p>Equivalent to <code class="code">near &lt;An&gt;</code>.
</p>
</dd>
<dt><code class="code">basereg &lt;expression&gt;,&lt;An&gt;</code></dt>
<dd><p>Starts a block of base-relative addressing through register <code class="code">An</code>
      (remember that <code class="code">A7</code> is not allowed as a base register).
      The developer has to make sure that &lt;expression&gt; is placed
      into <code class="code">An</code> first, while the assembler automatically subtracts
      &lt;expression&gt;, which is usually a program label with an optional offset,
      from each displacement in a <code class="code">(d,An)</code> addressing mode.
      <code class="code">basereg</code> has priority over the <code class="code">near</code> directive. Its effect
      can be suspended with the <code class="code">endb</code> directive.
      It is allowed to use several base registers in parallel.
</p>
</dd>
<dt><code class="code">cpu32</code></dt>
<dd><p>Generate code for the CPU32 family.
</p>
</dd>
<dt><code class="code">endb &lt;An&gt;</code></dt>
<dd><p>Ends a <code class="code">basereg</code> block and suspends its effect onto the
      specified base register <code class="code">An</code>. It may be reused with a different
      base expression thereafter (refer to <code class="code">basereg</code>).
</p>
</dd>
<dt><code class="code">far</code></dt>
<dd><p>Disables small data (base-relative) mode. All data references
      will be absolute.
</p>
</dd>
<dt><code class="code">fpu &lt;cpID&gt;</code></dt>
<dd><p>Enables 68881/68882 FPU code generation. The &lt;cpID&gt; is inserted
      into the FPU instructions to select the correct coprocessor. Note
      that &lt;cpID&gt; is always 1 for the on-chip FPUs in the 68040 and
      68060. A &lt;cpID&gt; of zero will disable FPU code generation.
</p>
</dd>
<dt><code class="code">initnear</code></dt>
<dd><p>Initializes the selected small data base register. In contrast to
      PhxAss, where this directive comes from, just a reference to
      <code class="code">_LinkerDB</code> is generated, which has to be resolved by a linker:
      <code class="code">lea _LinkerDB,An</code>
</p>
</dd>
<dt><code class="code">machine &lt;cpu_type&gt;</code></dt>
<dd><p>Makes the assembler generate code for &lt;cpu_type&gt;, which can be
      the following: <code class="code">68000</code>, <code class="code">68010</code>, <code class="code">68020</code>, <code class="code">68030</code>,
      <code class="code">68040</code>, <code class="code">68060</code>, <code class="code">68080</code>,
      <code class="code">68851</code>, <code class="code">68881</code>, <code class="code">68882</code>, <code class="code">cpu32</code>.
      And various ColdFire CPUs, starting with <code class="code">5...</code>.
</p>
</dd>
<dt><code class="code">mc68000</code></dt>
<dd><p>Generate code for the MC68000 CPU.
</p>
</dd>
<dt><code class="code">mc68010</code></dt>
<dd><p>Generate code for the MC68010 CPU.
</p>
</dd>
<dt><code class="code">mc68020</code></dt>
<dd><p>Generate code for the MC68020 CPU.
</p>
</dd>
<dt><code class="code">mc68030</code></dt>
<dd><p>Generate code for the MC68030 CPU.
</p>
</dd>
<dt><code class="code">mc68040</code></dt>
<dd><p>Generate code for the MC68040 CPU.
</p>
</dd>
<dt><code class="code">mc68060</code></dt>
<dd><p>Generate code for the MC68060 CPU.
</p>
</dd>
<dt><code class="code">ac68080</code></dt>
<dd><p>Generate code for the Apollo Core AC68080 FPGA CPU.
</p>
</dd>
<dt><code class="code">mcf5...</code></dt>
<dd><p>Generate code for a ColdFire CPU. The recognized models are listed
      in the assembler-options section.
</p>
</dd>
<dt><code class="code">near [&lt;An&gt;]</code></dt>
<dd><p>Enables small data (base-relative) mode and sets the base register
      to <code class="code">An</code>. <code class="code">near</code> without an argument will reactivate a
      previously defined small data mode, which might have been switched off
      by a <code class="code">far</code> directive.
</p>
</dd>
<dt><code class="code">near code</code></dt>
<dd><p>All <code class="code">JMP</code> and <code class="code">JSR</code> instructions to external labels
      will be converted into 16-bit PC-relative jumps. The small code
      mode can be switched off by a <code class="code">far</code> directive.
</p>
</dd>
<dt><code class="code">opt &lt;option&gt;[,&lt;option&gt;...]</code></dt>
<dd><p>Sets Devpac-compatible options. When option <samp class="option">-phxass</samp> is
      given, then it will parse PhxAss options instead (which is discouraged
      for new code, so there is no detailed description here).
      Most supported Devpac2-style options are always suffixed by a
      <code class="code">+</code> or <code class="code">-</code> to enable or disable the option:
   </p><dl class="table">
<dt><code class="code">a</code></dt>
<dd><p>Automatically optimize absolute to PC-relative references.
        Default is off in Devpac-comptability mode, otherwise on.
      </p></dd>
<dt><code class="code">c</code></dt>
<dd><p>Case-sensitivity for all symbols, instructions and macros.
        Default is on.
      </p></dd>
<dt><code class="code">d</code></dt>
<dd><p>Include all symbols for debugging in the output file. May also
        generate line debugging information in some output formats.
        Default is off in Devpac-comptability mode, otherwise on.
      </p></dd>
<dt><code class="code">l</code></dt>
<dd><p>Generate a linkable object file. The default is defined by the
        selected output format via the assembler&rsquo;s <samp class="option">-F</samp> option.
        This option was supported by Devpac-Amiga only.
      </p></dd>
<dt><code class="code">l0</code></dt>
<dt><code class="code">l1</code></dt>
<dt><code class="code">l2</code></dt>
<dd><p>Nonzero selects object file, zero selects executable file format,
        when Atari-TOS (<samp class="option">-Ftos</samp>) or Amiga-hunk output format
        (<samp class="option">-Fhunk</samp>) was set on the command line.
        This option was supported by Devpac-Atari only and its original
        function was to select TOS-executable (0), DRI-object (1) or
        GST-object (2) output. For GST objects use (<samp class="option">-Fgst</samp>) instead.
      </p></dd>
<dt><code class="code">o</code></dt>
<dd><p>Enable all optimizations (o1 to o12), or disable all optimizations.
        The default is that all are disabled in Devpac-compatibility mode
        and enabled otherwise.
        When running in native vasm mode this option will also enable
        PC-relative (<code class="code">opt a</code>) and
        the following safe vasm-specific optimizations (see below):
        <code class="code">og</code>, <code class="code">of</code>.
      </p></dd>
<dt><code class="code">o1</code></dt>
<dd><p>Optimize branches without an explicit size extension.
      </p></dd>
<dt><code class="code">o2</code></dt>
<dd><p>Standard displacement optimizations (e.g. <code class="code">(0,An) -&gt; (An)</code>).
      </p></dd>
<dt><code class="code">o3</code></dt>
<dd><p>Optimize absolute addresses to short words.
      </p></dd>
<dt><code class="code">o4</code></dt>
<dd><p>Optimize <code class="code">move.l</code> to <code class="code">moveq</code>.
      </p></dd>
<dt><code class="code">o5</code></dt>
<dd><p>Optimize <code class="code">add #x</code> and <code class="code">sub #x</code> into their quick forms.
      </p></dd>
<dt><code class="code">o6</code></dt>
<dd><p>No effect in vasm.
      </p></dd>
<dt><code class="code">o7</code></dt>
<dd><p>Replace <code class="code">bra.b</code> by a 2-byte no-operation instruction, like
        <code class="code">lea (a6),a6</code>, when branching to the next instruction.
        Note: <code class="code">nop</code> is not really a no-operation instruction on 68040
        and higher.
      </p></dd>
<dt><code class="code">o8</code></dt>
<dd><p>Optimize 68020+ base displacements to 16 bit.
      </p></dd>
<dt><code class="code">o9</code></dt>
<dd><p>Optimize 68020+ outer displacements to 16 bit.
      </p></dd>
<dt><code class="code">o10</code></dt>
<dd><p>Optimize <code class="code">add/sub #x,An</code> to <code class="code">lea</code>.
      </p></dd>
<dt><code class="code">o11</code></dt>
<dd><p>Optimize <code class="code">lea (d,An),An</code> to <code class="code">addq/subq</code>.
      </p></dd>
<dt><code class="code">o12</code></dt>
<dd><p>Optimize <code class="code">&lt;op&gt;.l #x,An</code> to <code class="code">&lt;op&gt;.w #x,An</code>.
      </p></dd>
<dt><code class="code">ow</code></dt>
<dd><p>Show all optimizations being performed.
        Default is on in Devpac-compatibility mode, otherwise off.
      </p></dd>
<dt><code class="code">p</code></dt>
<dd><p>Check if code is position independent. This will cause an error on
        every relocation entry being required.
        Default is off.
      </p></dd>
<dt><code class="code">s</code></dt>
<dd><p>Include symbols in listing file.
        Default is on.
      </p></dd>
<dt><code class="code">t</code></dt>
<dd><p>Check size and type of all expressions.
        Default is on.
      </p></dd>
<dt><code class="code">w</code></dt>
<dd><p>Show assembler warnings.
        Default is on.
      </p></dd>
<dt><code class="code">x</code></dt>
<dd><p>For Amiga hunk format objects <code class="code">x+</code> strips local symbols from
        the symbol table (symbols without <code class="code">xdef</code>).
        For Atari TOS executables this will enable the extended (HiSoft)
        DRI symbol table format, which allows symbols with up to 22
        characters. DRI standard only supports 8 characters.
   </p></dd>
</dl>

<p>Devpac options without +/- suffix:
   </p><dl class="table">
<dt><code class="code">l0</code></dt>
<dt><code class="code">l1</code></dt>
<dt><code class="code">l2</code></dt>
<dd><p>Nonzero selects object file, zero selects executable file format,
        when Atari-TOS (<samp class="option">-Ftos</samp>) or Amiga-hunk output format
        (<samp class="option">-Fhunk</samp>) was set on the command line.
        This option was supported by Devpac-Atari only and its original
        function was to select TOS-executable (0), DRI-object (1) or
        GST-object (2) output. For GST objects use (<samp class="option">-Fgst</samp>) instead.
      </p></dd>
<dt><code class="code">p=&lt;type&gt;[/&lt;type&gt;]</code></dt>
<dd><p>Sets the CPU type to any model vasm supports (Devpac only allows
        68000-68040, 68332, 68881, 68882 and 68851).
   </p></dd>
</dl>

<p>Also the following Devpac3-style options are supported:
   </p><dl class="table">
<dt><code class="code">autopc</code></dt>
<dd><p>Corresponds to <code class="code">a+</code>.
      </p></dd>
<dt><code class="code">case</code></dt>
<dd><p>Corresponds to <code class="code">c+</code>.
      </p></dd>
<dt><code class="code">chkpc</code></dt>
<dd><p>Corresponds to <code class="code">p+</code>.
      </p></dd>
<dt><code class="code">debug</code></dt>
<dd><p>Corresponds to <code class="code">d+</code>.
      </p></dd>
<dt><code class="code">symtab</code></dt>
<dd><p>Corresponds to <code class="code">s+</code>.
      </p></dd>
<dt><code class="code">type</code></dt>
<dd><p>Corresponds to <code class="code">t+</code>.
      </p></dd>
<dt><code class="code">warn</code></dt>
<dd><p>Corresponds to <code class="code">w+</code>.
      </p></dd>
<dt><code class="code">xdebug</code></dt>
<dd><p>Corresponds to <code class="code">x+</code>.
      </p></dd>
<dt><code class="code">noautopc</code></dt>
<dd><p>Corresponds to <code class="code">a-</code>.
      </p></dd>
<dt><code class="code">nocase</code></dt>
<dd><p>Corresponds to <code class="code">c-</code>.
      </p></dd>
<dt><code class="code">nochkpc</code></dt>
<dd><p>Corresponds to <code class="code">p-</code>.
      </p></dd>
<dt><code class="code">nodebug</code></dt>
<dd><p>Corresponds to <code class="code">d-</code>.
      </p></dd>
<dt><code class="code">nosymtab</code></dt>
<dd><p>Corresponds to <code class="code">s-</code>.
      </p></dd>
<dt><code class="code">notype</code></dt>
<dd><p>Corresponds to <code class="code">t-</code>.
      </p></dd>
<dt><code class="code">nowarn</code></dt>
<dd><p>Corresponds to <code class="code">w-</code>.
      </p></dd>
<dt><code class="code">noxdebug</code></dt>
<dd><p>Corresponds to <code class="code">x-</code>.
   </p></dd>
</dl>

<p>The following options are vasm specific and should not be used when
   writing portable source. Using <code class="code">opt o+</code> or <code class="code">opt o-</code> in
   Devpac mode only toggles <code class="code">og</code> and <code class="code">of</code>.
   </p><dl class="table">
<dt><code class="code">oa</code></dt>
<dd><p>Automatically optimize absolute Apollo destination operands to
        PC-relative references (requires 68080 code-generation enabled).
      </p></dd>
<dt><code class="code">ob</code></dt>
<dd><p>Convert absolute jumps to external labels into long-branches
        (refer to <samp class="option">-opt-jbra</samp>).
      </p></dd>
<dt><code class="code">oc</code></dt>
<dd><p>Enable optimizations to <code class="code">CLR</code> (refer to <samp class="option">-opt-clr</samp>).
      </p></dd>
<dt><code class="code">od</code></dt>
<dd><p>Enable optimization of divisions into shifts (refer to
        <samp class="option">-opt-div</samp>).
      </p></dd>
<dt><code class="code">of</code></dt>
<dd><p>Enable immediate float constant optimizations (refer to
        <samp class="option">-opt-fconst</samp>).
      </p></dd>
<dt><code class="code">og</code></dt>
<dd><p>Enable generic vasm optimizations. This includes all safe
        optimizations which cannot be controlled by another option.
      </p></dd>
<dt><code class="code">oj</code></dt>
<dd><p>Enable branch to jump translations (refer to <samp class="option">-opt-brajmp</samp>).
      </p></dd>
<dt><code class="code">ol</code></dt>
<dd><p>Enable shift optimizations to <code class="code">ADD</code> (refer to <samp class="option">-opt-lsl</samp>).
      </p></dd>
<dt><code class="code">om</code></dt>
<dd><p>Enable <code class="code">MOVEM</code> optimizations (refer to <samp class="option">-opt-movem</samp>).
      </p></dd>
<dt><code class="code">on</code></dt>
<dd><p>Enable small data optimizations. References to absolute symbols in a
        small data section (named &quot;__MERGED&quot;) are optimized into a
        base-relative addressing mode (refer to <samp class="option">-sd</samp>).
      </p></dd>
<dt><code class="code">op</code></dt>
<dd><p>Enable optimizations to <code class="code">PEA</code> (refer to <samp class="option">-opt-pea</samp>).
      </p></dd>
<dt><code class="code">oq</code></dt>
<dd><p>Optimizes <code class="code">MOVE.L</code> into a combination of <code class="code">MOVEQ</code> and
        <code class="code">NEG.W</code> (refer to <samp class="option">-opt-nmoveq</samp>).
      </p></dd>
<dt><code class="code">os</code></dt>
<dd><p>Optimize for speed before optimizing for size (refer to
        <samp class="option">-opt-speed</samp>).
      </p></dd>
<dt><code class="code">ot</code></dt>
<dd><p>Enable optimizations to <code class="code">ST</code> (refer to <samp class="option">-opt-st</samp>).
      </p></dd>
<dt><code class="code">ox</code></dt>
<dd><p>Enable optimization of multiplications into shifts
        (refer to <samp class="option">-opt-mul</samp>).
      </p></dd>
<dt><code class="code">oz</code></dt>
<dd><p>Enable optimization for size, even if the code becomes slower
        (refer to <samp class="option">-opt-size</samp>).
   </p></dd>
</dl>
<p>The default state is &rsquo;off&rsquo; for all these vasm specific options,
   except for <code class="code">of</code> and <code class="code">og</code>, which are &rsquo;on&rsquo;.
</p></dd>
</dl>

<p>The following directives are only available for the Motorola syntax
module:
</p>
<dl class="table">
<dt><code class="code">&lt;symbol&gt; equr &lt;Rn&gt;</code></dt>
<dd><p>Define a new symbol named &lt;symbol&gt; and assign the data or
      address register <code class="code">Rn</code>, which can be used from now on in operands.
      When 68080 code generation is enabled, also <code class="code">Bn</code> base address
      registers and <code class="code">En</code> vector registers are allowed to be assigned.
      Note that a register symbol must be defined before it can be
      used!
</p>
</dd>
<dt><code class="code">&lt;symbol&gt; equrl &lt;reglist&gt;</code></dt>
<dd><p>Equivalent to <code class="code">&lt;symbol&gt; reg &lt;reglist&gt;</code>.
</p>
</dd>
<dt><code class="code">&lt;symbol&gt; fequr &lt;FPn&gt;</code></dt>
<dd><p>Define a new symbol named &lt;symbol&gt; and assign the FPU register
      <code class="code">FPn</code>, which can be used from now on in operands.
      Note that a register symbol must be defined before it can be
      used!
</p>
</dd>
<dt><code class="code">&lt;symbol&gt; fequrl &lt;reglist&gt;</code></dt>
<dd><p>Equivalent to <code class="code">&lt;symbol&gt; freg &lt;reglist&gt;</code>.
</p>
</dd>
<dt><code class="code">&lt;symbol&gt; freg &lt;reglist&gt;</code></dt>
<dd><p>Defines a new symbol named &lt;symbol&gt; and assign the FPU register
      list &lt;reglist&gt; to it. Registers in a list must be separated
      by a slash (<code class="code">/</code>) and ranges or registers can be defined
      by using a hyphen (<code class="code">-</code>). No character at all represents
      an empty regiser list. Optionally you may specify the &lt;reglist&gt;
      as an 8-bit register mask constant (<code class="code">fp0</code> is bit 0, <code class="code">fp7</code>
      is bit 7). Examples for valid FPU register lists are: <code class="code">fp0-fp7</code>,
      <code class="code">fp1-3/fp5/fp7</code>, <code class="code">fpiar/fpcr</code>.
</p>
</dd>
<dt><code class="code">&lt;symbol&gt; reg &lt;reglist&gt;</code></dt>
<dd><p>Defines a new symbol named &lt;symbol&gt; and assign the register
      list &lt;reglist&gt; to it. Registers in a list must be separated
      by a slash (<code class="code">/</code>) and ranges or registers can be defined
      by using a hyphen (<code class="code">-</code>). No character at all represents
      an empty regiser list. Optionally you may specify the &lt;reglist&gt;
      as a 16-bit register mask constant (<code class="code">d0</code> is bit 0, <code class="code">a7</code>
      is bit 15). Examples for valid register lists are: <code class="code">d0-d7/a0-a6</code>,
      <code class="code">d3-6/a0/a1/a4-5</code>.
</p>
</dd>
</dl>


</div>
<div class="section-level-extent" id="Optimizations">
<h3 class="section"><span>6 Optimizations<a class="copiable-link" href="#Optimizations"> &para;</a></span></h3>

<ul class="mini-toc">
<li><a href="#Operand-optimizations" accesskey="1">Operand optimizations</a></li>
<li><a href="#Instruction-optimizations" accesskey="2">Instruction optimizations</a></li>
</ul>
<div class="subsection-level-extent" id="Operand-optimizations">
<h4 class="subsection"><span>6.1 Operand optimizations<a class="copiable-link" href="#Operand-optimizations"> &para;</a></span></h4>
<p>This backend performs the following operand optimizations:
</p>
<ul class="itemize mark-minus">
<li><code class="code">(0,An)</code> optimized to <code class="code">(An)</code>.

</li><li><code class="code">(d16,An)</code> translated to <code class="code">(bd32,An,ZDn.w)</code>, when <code class="code">d16</code> is not
 between -32768 and 32767 and the selected CPU allows it (68020 up or
 CPU32).

</li><li><code class="code">(d16,PC)</code> translated to <code class="code">(bd32,PC,ZDn.w)</code>, when <code class="code">d16</code> is not
 between -32768 and 32767 and the selected CPU allows it (68020 up or
 CPU32).

</li><li><code class="code">(d8,An,Rn)</code> translated to <code class="code">(bd,An,Rn)</code>, when <code class="code">d8</code> is not
 between -128 and 127 and the selected CPU allows it (68020 up or
 CPU32).

</li><li><code class="code">(d8,PC,Rn)</code> translated to <code class="code">(bd,PC,Rn)</code>, when <code class="code">d8</code> is not
 between -128 and 127 and the selected CPU allows it (68020 up or
 CPU32).

</li><li><code class="code">&lt;exp&gt;.l</code> optimized to <code class="code">&lt;exp&gt;.w</code>, when <code class="code">&lt;exp&gt;</code> is absolute
 and between -32768 and 32767.

</li><li><code class="code">&lt;exp&gt;.w</code> translated to <code class="code">&lt;exp&gt;.l</code>, when <code class="code">&lt;exp&gt;</code> is a program
 label or absolute and not between -32768 and 32767.

</li><li><code class="code">(0,An,...)</code> optimized to <code class="code">(An,...)</code> (which means the base
 displacement will be suppressed). This allows further optimization
 to <code class="code">(An)</code>, when the index is suppressed.

</li><li><code class="code">(bd16,An,...)</code> translated to <code class="code">(bd32,An,...)</code>, when <code class="code">bd16</code> is
 not between -32768 and 32767.

</li><li><code class="code">(bd32,An,...)</code> optimized to <code class="code">(bd16,An,...)</code>, when <code class="code">bd16</code> is
 between -32768 and 32767.

</li><li><code class="code">(bd32,An,ZRn)</code> optimized to <code class="code">(d16,An)</code>, when <code class="code">bd32</code> is
 between -32768 and 32767, and the index is suppressed (zero-Rn).

</li><li><code class="code">(An,ZRn)</code> optimized to <code class="code">(An)</code>, when the index is suppressed.

</li><li><code class="code">(0,PC,...)</code> optimized to <code class="code">(PC,...)</code> (which means the base
 displacement will be suppressed).

</li><li><code class="code">(bd16,PC,...)</code> translated to <code class="code">(bd32,PC,...)</code>, when <code class="code">bd16</code> is
 not between -32768 and 32767.

</li><li><code class="code">(bd32,PC,...)</code> optimized to <code class="code">(bd16,PC,...)</code>, when <code class="code">bd16</code> is
 between -32768 and 32767.

</li><li><code class="code">(bd32,PC,ZRn)</code> optimized to <code class="code">(d16,PC)</code>, when <code class="code">bd32</code> is
 between -32768 and 32767, and the index is suppressed (zero-Rn).

</li><li><code class="code">([0,Rn,...],...)</code> optimized to <code class="code">([An,...],...)</code> (which means the base
 displacement will be suppressed).

</li><li><code class="code">([bd16,Rn,...],...)</code> translated to <code class="code">([bd32,An,...],...)</code>, when <code class="code">bd16</code>
 is not between -32768 and 32768.

</li><li><code class="code">([bd32,Rn,...],...)</code> optimized to <code class="code">([bd16,An,...],...)</code>, when <code class="code">bd32</code>
 is between -32768 and 32768.

</li><li><code class="code">([...],0)</code> optimized to <code class="code">([...])</code> (which means the outer displacement
 will be suppressed).

</li><li><code class="code">([...],od16)</code> translated to <code class="code">([...],od32)</code>, when <code class="code">od16</code> is
 not between -32768 and 32767.

</li><li><code class="code">([...],od32)</code> translated to <code class="code">([...],od16)</code>, when <code class="code">od32</code> is
 between -32768 and 32767.

</li></ul>

<p>Note that an operand optimization will only take place when a displacement&rsquo;s
size was not enforced by the developer through an explicit size
extension (e.g. <code class="code">(4.l,a0)</code>)!
</p>
</div>
<div class="subsection-level-extent" id="Instruction-optimizations">
<h4 class="subsection"><span>6.2 Instruction optimizations<a class="copiable-link" href="#Instruction-optimizations"> &para;</a></span></h4>
<p>This backend performs the following instruction optimizations and
translations:
</p>
<ul class="itemize mark-minus">
<li><code class="code">&lt;op&gt;.L #x,An</code> optimized to <code class="code">&lt;op&gt;.W #x,An</code>, when <code class="code">x</code> is
 between -32768 and 32767.

</li><li><code class="code">ADD.? #x,&lt;ea&gt;</code> optimized to <code class="code">ADDQ.? #x,&lt;ea&gt;</code>, when <code class="code">x</code> is
 between 1 and 8.

</li><li><code class="code">ADD.? #x,&lt;ea&gt;</code> optimized to <code class="code">SUBQ.? #x,&lt;ea&gt;</code>, when <code class="code">x</code> is
 between -1 and -8.

</li><li><code class="code">ADDA.? #0,An</code> and <code class="code">SUBA.? #0,An</code> will be deleted.

</li><li><code class="code">ADDA.? #x,An</code> translated to <code class="code">LEA (x,An),An</code>, when <code class="code">x</code> is
 between -32768 and 32767.

</li><li><code class="code">ANDI.L #$ff,Dn</code> optimized to <code class="code">MVZ.B Dn,Dn</code>,
 for ColdFire ISA_B/C.

</li><li><code class="code">ANDI.L #$ffff,Dn</code> optimized to <code class="code">MVZ.W Dn,Dn</code>,
 for ColdFire ISA_B/C.

</li><li><code class="code">ANDI.? #0,&lt;ea&gt;</code> optimized to <code class="code">CLR.? &lt;ea&gt;</code>, when allowed
 by the option <samp class="option">-opt-clr</samp> or a different CPU than the MC68000 was
 selected.

</li><li><code class="code">ANDI.? #-1,&lt;ea&gt;</code> optimized to <code class="code">TST.? &lt;ea&gt;</code>.

</li><li><code class="code">ASL.? #1,Dn</code> optimized to <code class="code">ADD.? Dn,Dn</code> for 68000 and 68010.

</li><li><code class="code">ASL.? #2,Dn</code> optimized into a sequence of two <code class="code">ADD.? Dn,Dn</code>
for 68000 and 68010, when the operation size is either byte or word and
the options <samp class="option">-opt-speed</samp> and <samp class="option">-opt-lsl</samp> are given.

</li><li><code class="code">B&lt;cc&gt; &lt;label&gt;</code> translated into a combination of
 <code class="code">B!&lt;cc&gt; *+8</code> and <code class="code">JMP &lt;label&gt;</code>, when &lt;label&gt; is not defined in the
 same section (and option <samp class="option">-opt-brajmp</samp> is given),
 or outside the range of -32768 to 32767 bytes from the current address
 when the selected CPU is not 68020 up, CPU32 or ColdFire ISA_B/C.

</li><li><code class="code">B&lt;cc&gt; &lt;label&gt;</code> is automatically optimized to 8-bit, 16-bit or
 32-bit (68020 up, CPU32, MCF5407 only), whatever fits best. When the
 selected CPU doesn&rsquo;t support 32-bit branches it will try to change the
 conditional branch into a <code class="code">B&lt;!cc&gt; *+8</code> and <code class="code">JMP &lt;label&gt;</code> sequence.

</li><li><code class="code">BRA &lt;label&gt;</code> translated to <code class="code">JMP &lt;label&gt;</code>, when &lt;label&gt; is
 not defined in the same section (and option <samp class="option">-opt-brajmp</samp> is given),
 or outside the range of -32768 to 32767 bytes from the current address
 when the selected CPU is not 68020 up, CPU32 or ColdFire ISA_B/C.

</li><li><code class="code">BSR &lt;label&gt;</code> translated to <code class="code">JSR &lt;label&gt;</code>, when &lt;label&gt; is
 not defined in the same section (and option <samp class="option">-opt-brajmp</samp> is given),
 or outside the range of -32768 to 32767 bytes from the current address
 when the selected CPU is not 68020 up, CPU32 or ColdFire ISA_B/C.

</li><li><code class="code">&lt;cp&gt;B&lt;cc&gt; &lt;label&gt;</code> is automatically optimized to 16-bit or 32-bit,
 whatever fits best. &lt;cp&gt; means coprocessor and is <code class="code">P</code> for the PMMU
 and <code class="code">F</code> for the FPU.

</li><li><code class="code">CLR.L Dn</code> optimized to <code class="code">MOVEQ #0,Dn</code>.

</li><li><code class="code">CMP.? #0,&lt;ea&gt;</code> optimized to <code class="code">TST.? &lt;ea&gt;</code>. The selected CPU type
 must be MC68020 up, ColdFire or CPU32 to support address register direct
 as effective address (<code class="code">&lt;ea&gt;</code>).

</li><li><code class="code">DIVS.W/DIVU.W #1,Dn</code> optimized to <code class="code">MVZ.W Dn,Dn</code>, for
ColdFire ISA_B/C (<samp class="option">-opt-div</samp>).

</li><li><code class="code">DIVS.W #-1,Dn</code> optimized to the sequence of <code class="code">NEG.W Dn</code> and
<code class="code">MVZ.W Dn,Dn</code> (<samp class="option">-opt-div</samp> and <samp class="option">-opt-speed</samp>).

</li><li><code class="code">DIVS.L/DIVU.L #1,Dn</code> optimized to <code class="code">TST.L Dn</code>
(<samp class="option">-opt-div</samp>).

</li><li><code class="code">DIVS.L #-1,Dn</code> optimized to <code class="code">NEG.L Dn</code>
(<samp class="option">-opt-div</samp>).

</li><li><code class="code">DIVU.L #2..256,Dn</code> optimized to <code class="code">LSR.L #x,Dn</code>
(<samp class="option">-opt-div</samp>).

</li><li><code class="code">EORI.? #-1,&lt;ea&gt;</code> optimized to <code class="code">NOT.? &lt;ea&gt;</code>.

</li><li><code class="code">EORI.? #0,&lt;ea&gt;</code> optimized to <code class="code">TST.? &lt;ea&gt;</code>.

</li><li><code class="code">FMOVEM.? &lt;reglist&gt;</code> is deleted when the register list was empty.

</li><li><code class="code">FxDIV.? #m,FPn</code> optimized to <code class="code">FxMUL.? #1/m,FPn</code> when m is
a power of 2 and option <samp class="option">-opt-fconst</samp> is given.

</li><li><code class="code">JMP &lt;label&gt;</code> optimized to <code class="code">BRA.? &lt;label&gt;</code>, when &lt;label&gt; is defined
 in the same section and in the range of -32768 to 32767 bytes from the
 current address.
 Note that <code class="code">JMP (&lt;lab&gt;,PC)</code> is never optimized, with the intention
 to preserve jump-tables.

</li><li><code class="code">JSR &lt;label&gt;</code> optimized to <code class="code">BSR.? &lt;label&gt;</code>, when &lt;label&gt; is defined
 in the same section and in the range of -32768 to 32767 bytes from the
 current address.
 Note that <code class="code">JSR (&lt;lab&gt;,PC)</code> is never optimized, with the intention
 to preserve jump-tables.

</li><li><code class="code">LEA 0,An</code> optimized to <code class="code">SUBA.L An,An</code>.

</li><li><code class="code">LEA (0,An),An</code> and <code class="code">LEA (An),An</code> will be deleted.

</li><li><code class="code">LEA (d,An),An</code> is optimized to <code class="code">ADDQ.L #d,An</code> when <code class="code">d</code>
 is between 1 and 8 and to <code class="code">SUBQ.L #-d,An</code> when <code class="code">d</code> is between
 -1 and -8.

</li><li><code class="code">LEA (d,Am),An</code> will be translated into a combination of
 <code class="code">MOVEA</code> and <code class="code">ADDA.L</code> for 68000 and 68010, when <code class="code">d</code> is lower
 than -32768 or higher than 32767. The <code class="code">MOVEA</code> will be omitted when
 <code class="code">Am</code> and <code class="code">An</code> are identical. Otherwise <samp class="option">-opt-speed</samp> is
 required.

</li><li><code class="code">LINK.L An,#x</code> optimized to <code class="code">LINK.W An,#x</code>, when <code class="code">x</code> is
 between -32768 and 32767.

</li><li><code class="code">LINK.W An,#x</code> translated to <code class="code">LINK.L An,#x</code>, when <code class="code">x</code> is
 not between -32768 and 32767 and selected CPU supports this instruction.

</li><li><code class="code">LSL.? #1,Dn</code> optimized to <code class="code">ADD.? Dn,Dn</code> for 68000 and 68010,
 when option <samp class="option">-opt-lsl</samp> is given.

</li><li><code class="code">LSL.? #2,Dn</code> optimized into a sequence of two <code class="code">ADD.? Dn,Dn</code>
for 68000 and 68010, when the operation size is either byte or word and
the options <samp class="option">-opt-speed</samp> and <samp class="option">-opt-lsl</samp> are given.

</li><li><code class="code">MOVE.? #0,&lt;ea&gt;</code> optimized to <code class="code">CLR.? &lt;ea&gt;</code>, when allowed by
 the option <samp class="option">-opt-clr</samp> or a different CPU than the MC68000 was
 selected.

</li><li><code class="code">MOVE.? #x,-(SP)</code> optimized to <code class="code">PEA x</code>, when allowed by the
 option <samp class="option">-opt-pea</samp>. The move-size must not be byte (<code class="code">.b</code>).

</li><li><code class="code">MOVE.B #-1,&lt;ea&gt;</code> optimized to <code class="code">ST &lt;ea&gt;</code>, when allowed by the
 option <samp class="option">-opt-st</samp>.

</li><li><code class="code">MOVE.L #x,Dn</code> optimized to <code class="code">MOVEQ #x,Dn</code>, when <code class="code">x</code> is
 between -128 and 127.

</li><li><code class="code">MOVE.L #x,Dn</code> optimized to the sequence of <code class="code">MOVEQ #x&gt;&gt;1,Dn</code>
 and <code class="code">ADD.W Dn,Dn</code>, when <code class="code">128&lt;=x&lt;=254</code> and <code class="code">x</code> is even.

</li><li><code class="code">MOVE.L #x,Dn</code> optimized to the sequence of <code class="code">MOVEQ #x^$ff,Dn</code>
 and <code class="code">NOT.B Dn</code>, when <code class="code">128&lt;=x&lt;=255</code> and the option
 <samp class="option">-opt-nmoveq</samp> was set.

</li><li><code class="code">MOVE.L #x,Dn</code> optimized to the sequence of <code class="code">MOVEQ #x&gt;&gt;16,Dn</code>
 and <code class="code">SWAP Dn</code>, when <code class="code">$10000&lt;=x&lt;=$7f0000</code> or
 <code class="code">$ff80ffff&lt;=x&lt;=$fffeffff</code>.

</li><li><code class="code">MOVE.L #x,Dn</code> optimized to the sequence of
 <code class="code">MOVEQ #-((int16_t)x),Dn</code> and <code class="code">NEG.W Dn</code>, when <code class="code">$ff81&lt;=x&lt;=$ffff</code>
 or <code class="code">$ffff0001&lt;=x&lt;=$ffff0080</code> and the option <samp class="option">-opt-nmoveq</samp> was set.

</li><li><code class="code">MOVE.L #x,Dn</code> optimized to the sequence of <code class="code">MOVEQ #x&gt;&gt;n,Dn</code>
 and <code class="code">LSL.W #n,Dn</code>, when <code class="code">0&lt;=x&lt;=$7fff</code> and the difference between
 the highest and lowest bit set is less than 8.
 <samp class="option">-opt-size</samp> needs to be set together with standard optimizations.

</li><li><code class="code">MOVE.L #x,&lt;ea&gt;</code> optimized to <code class="code">MOV3Q #x,&lt;ea&gt;</code>, for ColdFire
 ISA_B and ISA_C, when <code class="code">x</code> is -1 or between 1 and 7.

</li><li><code class="code">MOVEA.? #0,An</code> optimized to <code class="code">SUBA.L An,An</code>.

</li><li><code class="code">MOVEA.L #x,An</code> optimized to <code class="code">MOVEA.W #x,An</code>, when <code class="code">x</code> is
 between -32768 and 32767.

</li><li><code class="code">MOVEA.L #label,An</code> optimized to <code class="code">LEA label,An</code>, which could
 allow further optimization to <code class="code">LEA label(PC),An</code>.

</li><li><code class="code">MOVEM.? &lt;reglist&gt;</code> is deleted, when the register list was empty.

</li><li><code class="code">MOVEM.? &lt;ea&gt;,An</code> optimized to <code class="code">MOVE.? &lt;ea&gt;,An</code>, when the
 register list only contains a single address register.

</li><li><code class="code">MOVEM.? &lt;ea&gt;,Rn</code> optimized to <code class="code">MOVE.? &lt;ea&gt;,Rn</code> and
 <code class="code">MOVEM.? Rn,&lt;ea&gt;</code> optimized to <code class="code">MOVE.? Rn,&lt;ea&gt;</code>, when allowed
 by the option <samp class="option">-opt-movem</samp> or when just loading an address register.

</li><li><code class="code">MOVEM.? &lt;ea&gt;,Rm/Rn</code> and <code class="code">MOVEM.? Rm/Rn,&lt;ea&gt;</code> are optimized
 into a sequence of two <code class="code">MOVE</code> instructions when advantageous for
 the currently selected CPU.
 For example, for 68000 and 68010 it is no advantage to optimize
 <code class="code">MOVEM Rm/Rn,-(An)</code>, and addressing modes with displacements
 or absolute addresses are optimized for 68040 only (may additionally
 require <samp class="option">-opt-speed</samp>).

</li><li><code class="code">MULS.?/MULU.? #0,Dn</code> optimized to <code class="code">MOVEQ #0,Dn</code>
(<samp class="option">-opt-mul</samp>).

</li><li><code class="code">MULS.?/MULU.? #1,Dn</code> is deleted (<samp class="option">-opt-mul</samp>).

</li><li><code class="code">MULS.W #-1,Dn</code> optimized to the sequence <code class="code">EXT.L Dn</code> and
<code class="code">NEG.L Dn</code> (<samp class="option">-opt-mul</samp> and <samp class="option">-opt-speed</samp>).

</li><li><code class="code">MULS.L #-1,Dn</code> optimized to <code class="code">NEG.L Dn</code> (<samp class="option">-opt-mul</samp>).

</li><li><code class="code">MULS.W #2..256,Dn</code> optimized to the sequence <code class="code">EXT.L Dn</code> and
<code class="code">ASL.L #x,Dn</code> (<samp class="option">-opt-mul</samp> and <samp class="option">-opt-speed</samp>).

</li><li><code class="code">MULS.W #-2..-256,Dn</code> optimized to the sequence <code class="code">EXT.L Dn</code>,
<code class="code">ASL.L #x,Dn</code> and <code class="code">NEG.L Dn</code> (<samp class="option">-opt-mul</samp> and <samp class="option">-opt-speed</samp>).

</li><li><code class="code">MULS.L #2..256,Dn</code> optimized to <code class="code">ASL.L #x,Dn</code>
(<samp class="option">-opt-mul</samp>).

</li><li><code class="code">MULS.L #-2..-256,Dn</code> optimized to the sequence <code class="code">ASL.L #x,Dn</code>
and <code class="code">NEG.L Dn</code> (<samp class="option">-opt-mul</samp> and <samp class="option">-opt-speed</samp>).

</li><li><code class="code">MULU.W #2..256,Dn</code> optimized to the sequence <code class="code">MVZ.W Dn,Dn</code> and
<code class="code">ASL.L #x,Dn</code> for ColdFire ISA_B/C (<samp class="option">-opt-mul</samp> and <samp class="option">-opt-speed</samp>).

</li><li><code class="code">MULU.L #2..256,Dn</code> optimized to <code class="code">LSL.L #x,Dn</code>
(<samp class="option">-opt-mul</samp>).

</li><li><code class="code">MVZ.? #x,Dn</code> and <code class="code">MVS.? #x,Dn</code> are optimized to
 <code class="code">MOVEQ #x,Dn</code>.

</li><li><code class="code">ORI.? #0,&lt;ea&gt;</code> optimized to <code class="code">TST.? &lt;ea&gt;</code>.

</li><li><code class="code">SUB.? #x,&lt;ea&gt;</code> optimized to <code class="code">SUBQ.? #x,&lt;ea&gt;</code>, when <code class="code">x</code> is
 between 1 and 8.

</li><li><code class="code">SUB.? #x,&lt;ea&gt;</code> optimized to <code class="code">ADDQ.? #x,&lt;ea&gt;</code>, when <code class="code">x</code> is
 between -1 and -8.

</li><li><code class="code">SUBA.? #x,An</code> translated to <code class="code">LEA (-x,An),An</code>, when <code class="code">x</code> is
 between -32767 and 32768.

</li></ul>

</div>
</div>
<div class="section-level-extent" id="Known-Problems">
<h3 class="section"><span>7 Known Problems<a class="copiable-link" href="#Known-Problems"> &para;</a></span></h3>

<p>Some known problems of this module at the moment:
</p>
<ul class="itemize mark-minus">
<li>In some rare cases, mainly by stupid input sources, the optimizer
might oscillate forever between two states. When this happens, assembly
will be terminated automatically after some time.

</li><li>When using <code class="code">FMOVE</code> immediate addressing modes, but without
specifying a size extension, constants between <code class="code">$80000000</code> and
<code class="code">$ffffffff</code> are stored with 32 bits, which leads to sign-extension
problems when the instruction is really 64 or 96 bits.

</li></ul>

</div>
<div class="section-level-extent" id="Error-Messages">
<h3 class="section"><span>8 Error Messages<a class="copiable-link" href="#Error-Messages"> &para;</a></span></h3>

<p>This module has the following error messages:
</p>
<ul class="itemize mark-minus">
<li>2001: instruction not supported on selected architecture
</li><li>2002: illegal addressing mode
</li><li>2003: invalid register list
</li><li>2004: missing ) in register indirect addressing mode
</li><li>2005: address register required
</li><li>2006: bad size extension
</li><li>2007: displacement at bad position
</li><li>2008: base or index register expected
</li><li>2009: missing ] in memory indirect addressing mode
</li><li>2010: no extension allowed here
</li><li>2011: illegal scale factor
</li><li>2012: can&rsquo;t scale PC register
</li><li>2013: index register expected
</li><li>2014: too many ] in memory indirect addressing mode
</li><li>2015: missing outer displacement
</li><li>2016: %c expected
</li><li>2017: can&rsquo;t use PC register as index
</li><li>2018: double registers in list
</li><li>2019: data register required
</li><li>2020: illegal bitfield width/offset
</li><li>2021: constant integer expression required
</li><li>2022: value from -64 to 63 required for k-factor
</li><li>2023: need 32 bits to reference a program label
</li><li>2024: option expected
</li><li>2025: absolute value expected
</li><li>2026: operand value out of range: %ld (valid: %ld..%ld)
</li><li>2027: label in operand required
</li><li>2028: using signed operand as unsigned: %ld (valid: %ld..%ld), %ld to fix
</li><li>2029: branch destination out of range
</li><li>2030: displacement out of range
</li><li>2031: absolute displacement expected
</li><li>2032: unknown option %c%c ignored
</li><li>2033: absolute short address out of range
</li><li>2034: 8-bit branch with zero displacement was converted to 16-bit
</li><li>2035: illegal opcode extension
</li><li>2036: extension for unsized instruction ignored
</li><li>2037: immediate operand out of range
</li><li>2038: immediate operand has illegal type or size
</li><li>2039: data objects with %d bits size are not supported
</li><li>2040: data out of range
</li><li>2041: data has illegal type
</li><li>2042: illegal combination of ColdFire addressing modes
</li><li>2043: FP register required
</li><li>2044: unknown cpu type
</li><li>2045: register expected
</li><li>2046: link.w changed to link.l
</li><li>2047: branch out of range changed to jmp
</li><li>2048: lea-displacement out of range, changed into move/add
</li><li>2049: translated (A%d) into (0,A%d) for movep
</li><li>2050: operand optimized: %s
</li><li>2051: operand translated: %s
</li><li>2051: instruction optimized: %s
</li><li>2053: instruction translated: %s
</li><li>2054: branch optimized into: b&lt;cc&gt;.%c
</li><li>2055: branch translated into: b&lt;cc&gt;.%c
</li><li>2056: basereg A%d already in use
</li><li>2057: basereg A%d is already free
</li><li>2058: short-branch to following instruction turned into a nop
</li><li>2059: not a valid small data register
</li><li>2060: small data mode is not enabled
</li><li>2061: division by zero
</li><li>2062: can&rsquo;t use B%d register as index
</li><li>2063: register list on both sides
</li><li>2064: &quot;%s&quot; directive was replaced by an instruction with the same name
</li><li>2065: Addr.reg. operand at level #0 causes F-line exception
</li><li>2066: Dr and Dq are identical, transforming DIVxL.L effectively into DIVx.L
</li><li>2068: trailing garbage in operand
</li><li>2069: encoding absolute displacement directly
</li><li>2070: internal symbol %s has been modified
</li><li>2071: instruction too large for bank prefix
</li><li>2072: bad FPU id %d for selected cpu type
</li><li>2073: absolute k-factor without &rsquo;#&rsquo;
</li><li>2074: %d-bit access to absolute address
</li></ul>
</div>



</body>
</html>
